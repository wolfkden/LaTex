%\documentclass[aps,twocolumn,secnumarabic,graphics,flotfix,graphicx,
%url,bm,tightenlines,nobibnotes,nobalancelastpage,amsmath,amssymb,
%nofootinbib]{article}
\documentclass[aps,twocolumn,secnumarabic,nobalancelastpage,amsmath,amssymb,
amsthm,nofootinbib,parskip=full]{revtex4}

% standard graphics specifications
% alternative graphics specifications
% helps with long table options
% for on-line citations
% special 'bold-math' package

\usepackage{utf8}{inputenc}
%\usepackage[bottom]{footmisc}
\usepackage{titlesec}
\usepackage{mathtools}
\usepackage{graphics}      % standard graphics specifications
\usepackage{graphicx}      % alternative graphics specifications
\usepackage{longtable}     % helps with long table options
\usepackage{url}           % for on-line citations
\usepackage{bm}            % special 'bold-math' package
%\usepackage{unicode-math}
\usepackage{stmaryrd}
\usepackage{mathrsfs}
%\usepackage{mathabx}
%\setmathfont{XITS Math}
%\setmathfont[version=setB,StylisticSet=1]{XITS Math}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{pgf, tikz, tikz-cd}
\usepackage{chngcntr}
\counterwithin{figure}{section}
\usepackage{calrsfs}
\usepackage{stringstrings}
\usepackage{xstring}

\DeclareMathAlphabet{\pazocal}{OMS}{zplm}{m}{n}
%\DeclareMathAlphabet{\eurocal}{OMS}{zplm}{m}{n}
\usepackage{calligra}
\usepackage[T1]{fontenc}
\DeclareFontShape{T1}{calligra}{m}{n}{<->s*[1.2]callig15}{}
\DeclareMathAlphabet{\classscr}{T1}{calligra}{m}{n}
\usepackage[mathscr]{euscript}
\let\euscr\mathscr \let\mathscr\relax% just so we can load this and rsfs
\usepackage[scr]{rsfso}
\usepackage{relsize}

\usetikzlibrary{matrix,arrows, decorations,
  positioning, automata, calc, fit, shapes.geometric}
\newtheorem{theorem}{Theorem}[section]
\newtheorem{proposition}{Proposition}[section]
\newtheorem{corollary}{Corollary}[theorem]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proof}{Proof}[theorem]
\newtheorem{axiom}{Axiom}

\numberwithin{equation}{section}

%%\theoremstype{definition}
\newtheorem{definition}{Definition}[section]
%\newtheorem*{remark}{Remark}

%\setlength{\parskip}{\baselineskip}
%\setlength{\parskip}{4em}

\tikzset{every loop/.style={min distance=12mm,looseness=10}}
\tikzset{place/.style={circle,thick,minimum size=8mm}}
\tikzset{
modal/.style={>=stealthâ€™,shorten >=1pt,shorten <=1pt,auto,node distance=1.5cm,
semithick},
world/.style={circle,draw,minimum size=0.5cm,fill=gray!15},
point/.style={circle,draw,inner sep=0.5mm,fill=black},
reflexive above/.style={->,loop,looseness=7,in=120,out=60},
reflexive below/.style={->,loop,looseness=7,in=240,out=300},
reflexive left/.style={->,loop,looseness=7,in=150,out=210},
reflexive right/.style={->,loop,looseness=7,in=30,out=330}
}

\newcommand*{\xslant}[2][70]{%
  \begingroup
    \sbox0{#2}%
    \pgfmathsetlengthmacro\wdslant{\the\wd0 + cos(#1)*\the\wd0}%
    \leavevmode
    \hbox to \wdslant{\hss
      \tikz[
        baseline=(X.base),
        inner sep=0pt,
        transform canvas={xslant=cos(#1)},
      ] \node (X) {\usebox0};%
      \hss
      \vrule width 0pt height\ht0 depth\dp0 %
    }%
  \endgroup
}

\makeatletter
\newcommand*{\xslantmath}{}
\def\xslantmath#1#{%
  \@xslantmath{#1}%
}
\newcommand*{\@xslantmath}[2]{%
  % #1: optional argument for \xslant including brackets
  % #2: math symbol
  \ensuremath{%
    \mathpalette{\@@xslantmath{#1}}{#2}%
  }%
}
\newcommand*{\@@xslantmath}[3]{%
  % #1: optional argument for \xslant including brackets
  % #2: math style
  % #3: math symbol
  \xslant#1{$#2#3\m@th$}%
}
\makeatother

\newcommand{\nlessdot}{\mathrlap{\lessdot}\;|\;\,}

\newcommand{\gtrplus}{\mathrlap
  {\textbf{\raisebox{1.15pt}{\hspace{2.6pt}\scalebox{.4}{+}}}}>}
\newcommand{\padtxt}[1]{\hspace*{1em}\parsecat{#1}\hspace*{1em}}

\newcommand{\abk}[1]{\xslantmath{\mathfrak{#1}}}
%\newcommand{\subp}[1]{\xslantmath{\mathscr{#1}}}
\newcommand{\subp}[1]{\mathbf{#1}}
\newcommand{\obk}[1]{\mathpzc{#1}}
\newcommand{\diag}[1]{\mathbf{\mathsf{#1}}}
\newcommand{\diagobj}[1]{\diag{#1}_0}
\newcommand{\diagarr}[1]{\diag{#1}_1}
\newcommand{\diagdom}[1]{\oper{dom}\diag{#1}}
\newcommand{\diagcod}[1]{\oper{cod}\diag{#1}}
%\newcommand{\cat}[1]{\pazocal{#1}}
\newcommand{\cat}[1]{\pazocal{#1}}
\newcommand{\iarr}[1]{{\large \abk{i}}_{\obk{#1}}}
\newcommand{\tarr}[1]{{\large \abk{t}}_{\obk{#1}}}
\newcommand{\earr}[1]{{\large \abk{e}}_{\obk{#1}}}
\newcommand{\earrid}[1]{\oper{id}_{\obk{#1}}}
\newcommand{\earrdom}[1]{\oper{dom}\earr{#1}}
\newcommand{\earrcod}[1]{\oper{cod}\earr{#1}}
\newcommand{\arr}[1]{{\large \abk{a}}_{\obk{#1}}}
\newcommand{\arrid}[1]{\oper{id}_{\obk{#1}}}
\newcommand{\arrdom}[1]{\oper{dom}\arr{#1}}
\newcommand{\arrcod}[1]{\oper{cod}\arr{#1}}
\newcommand{\arrrel}[1]{\oper{rel}\arr{#1}}
\newcommand{\oarr}[2]{{\large \abk{a}}_{{\obk{#1},\obk{#2}}}}
\newcommand{\oarrid}[2]{\oper{id}_{\subp{#1},\obk{#2}}}
\newcommand{\oarrdom}[2]{\oper{dom}\oarr{#1}{#2}}
\newcommand{\oarrcod}[2]{\oper{cod}\oarr{#1}{#2}}
\newcommand{\oarrrel}[2]{\oper{rel}\oarr{#1}{#2}}
\newcommand{\arrn}[2]{{\large \abk{a}}^{#2}_{\obk{#1}}}
\newcommand{\ccid}[1]{\cat{#1}_{\oper{id}}}
\newcommand{\ccobj}[1]{\cat{#1}_{\subp{0}}}
\newcommand{\ccarr}[1]{\cat{#1}_{\subp{1}}}
\newcommand{\occarr}[2]{\cat{#2}_{\subp{#1}}}
\newcommand{\ocatarr}[2]{\parsecat{#2}_{\subp{#1}}}
\newcommand{\catarr}[1]{\parsecat{#1}_{\subp{1}}}
\newcommand{\catobj}[1]{\parsecat{#1}_{\subp{0}}}
\newcommand{\owraparr}[2]{(#2)_{\subp{#1}}}
\newcommand{\wrpcobj}[1]{#1_{,\subp{0}}}
\newcommand{\wrpcarr}[1]{#1_{,\subp{1}}}
\newcommand{\owrparr}[2]{{#2}_{\subp{#1}}}
\newcommand{\wrparr}[1]{#1_{\subp{1}}}
\newcommand{\wrpobj}[1]{#1_{\subp{0}}}
\newcommand{\wraparr}[1]{(#1)_{\subp{1}}}
\newcommand{\wrapobj}[1]{(#1)_{\subp{0}}}
\newcommand{\catfull}[1]{\cat{#1}(\ccobj{#1},\ccarr{#1})}
\newcommand{\oper}[1]{\mathbf{#1}\,}
\newcommand{\catN}[1]{\mathbf{\large #1}}
\newcommand{\initcat}{\catN{0}}
\newcommand{\termcat}{\catN{1}}
\newcommand{\singleton}[1]{\catN{1}_{#1}}
\newcommand{\singletoncat}[1]{\singleton{\parsecat{#1}}}
\newcommand{\fst}[1]{\oper{fst}\,#1}
\newcommand{\snd}[1]{\oper{snd}\,#1}
\newcommand{\adj}[2]{#1\dashv #2}
\newcommand{\adjcat}[2]{\pazocal{#1}\dashv\pazocal{#2}}
\newcommand{\adjfunct}[2]{\funct{#1}\dashv\funct{#2}}
\newcommand{\adjnat}[2]{\nfunct{#1}\dashv\nfunct{#2}}
\newcommand{\adjcom}[2]
{\funct{#2}\circ\funct{#1}\dashv\funct{#1}\circ\funct{#2}}
\newcommand{\adjtpl}[3]{(\parsecat{#1},\,\funct{#2},\,\nfunct{#3})}
\newcommand{\adjdbl}[2]{(\funct{#2},\,\nfunct{#3})}
\newcommand{\montpl}[3]{\mathsf{T}(\funct{#1},\,\nfunct{#2},\,\nfunct{#3})}

\newcommand{\efarr}[3]{\oarr{#1}{\epair{#2}{#3}}}
\newcommand{\ofarr}[3]{\oarr{#1}{\ffpair{#2}{#3}}}
\newcommand{\ofarrid}[3]{\langle\arrid{{#1}^*},\,\arrid{#2}\rangle}
\newcommand{\ofarrdom}[3]{\oper{dom}\ofarr{#1}{#2}{#3}}
\newcommand{\ofarrcod}[3]{\oper{cod}\ofarr{#1}{#2}{#3}}
\newcommand{\farr}[2]{\arr{\fpair{#1}{#2}}}
\newcommand{\farrid}[2]{\langle\arrid{#1},\,\arrid{#2}\rangle}
\newcommand{\farrdom}[2]{\oper{dom}\farr{#1}{#2}}
\newcommand{\farrcod}[2]{\oper{cod}\farr{#1}{#2}}
\newcommand{\ffarrdom}[2]{\oper{dom}_{\obk{1}}\farr{#1}{#2}}
\newcommand{\ffarrcod}[2]{\oper{cod}_{\obk{1}}\farr{#1}{#2}}
\newcommand{\arrpidom}[1]{\nprojdown{1}{\oper{dom}}\arr{#1}}
\newcommand{\arrpicod}[1]{\nprojdown{1}{\oper{cod}}\arr{#1}}
\newcommand{\farrpidomn}[2]{\arrpidom{\oarr{#1}{#2}}}
\newcommand{\farrpicodn}[2]{\arrpicod{\oarr{#1}{#2}}}
\newcommand{\farrpidom}[2]{\arrpidom{\fpair{#1}{#2}}}
\newcommand{\farrpicod}[2]{\arrpicod{\fpair{#1}{#2}}}
\newcommand{\arrpifst}[2]{\nprojfst{1}{\farr{#1}{#2}}}
\newcommand{\arrpisnd}[2]{\nprojsnd{1}{\farr{#1}{#2}}}
\newcommand{\oarrpiop}[3]{\nprojdown{#1}{\oper{#2}}\,#3}
\newcommand{\arrpiop}[2]{\oarrpiop{1}{#1}{#2}}

\newcommand{\largenat}{\mathpzc{NAT}}
\newcommand{\wrpcat}[1]{#1_{\functscr{O}}}
\newcommand{\wrpfunct}[1]{#1_{\functscr{F}}}
\newcommand{\wrpnat}[1]{#1_{\functscr{N}}}
\newcommand{\largenatcat}{\wrpcat{\largenat}}
\newcommand{\largenatfunct}{\wrpfunct{\largenat}}
\newcommand{\largenatnat}{\wrpnat{\largenat}}
\newcommand{\cnat}[2]{\largenat\cpr{#1}{#2}}
\newcommand{\cfnat}[2]{\largenat\fpair{#1}{#2}}
\newcommand{\natfunct}[2]{\wrpfunct{\cnat{#1}{#2}}}
\newcommand{\natnat}[2]{\wrpnat{\cnat{#1}{#2}}}
\newcommand{\nfunctscr}{\functscr{N}}
\newcommand{\nfunct}[1]{\nfunctscr_{\obk{#1}}}
\newcommand{\nfunctdom}[1]{\oper{dom}\,\nfunct{\obk{#1}}}
\newcommand{\nfunctcod}[1]{\oper{cod}\,\nfunct{\obk{#1}}}
\newcommand{\nfunctobj}[1]{\nfunctscr_{obk{#1},\subp{2}}}
\newcommand{\nfunctarr}[1]{\nfunctscr_{\obk{#1},\subp{3}}}

\newcommand{\cone}[2]{\mathpzc{CONE}\cpr{#1}{#2}}
\newcommand{\conefunct}[2]{{\mathpzc{CONE}\wrpfunct{\cpr{#1}{#2}}}}
\newcommand{\conenat}[2]{{\mathpzc{CONE}\wrpnat{\cpr{#1}{#2}}}}
\newcommand{\cocone}[2]{\mathpzc{COCO}\cpr{#1}{#2}}
\newcommand{\coconefunct}[2]{{\mathpzc{COCO}\wrpfunct{\cpr{#1}{#2}}}}
\newcommand{\coconenat}[2]{{\mathpzc{COCO}\wrpnat{\cpr{#1}{#2}}}}

\newcommand{\functbag}[1]{\llbracket #1\rrbracket}

%{{\raisebox{.1\baselineskip}{\ensuremath{\digamma}}}}
%{\mathrlap{\lessdot}\;|\;\,}
\newcommand{\oprojection}[2]{\xslantmath{\mathsf{P}}_
  {\!\!\overset{#2}{#1}}}
\newcommand{\nprojection}[1]{\xslantmath{\mathsf{P}}_
  {\!\!\shortdownarrow\!\raisebox{.3\baselineskip}{\scalebox{.5}{#1}}}}
\newcommand{\nprojdown}[2]{\nprojection{#1}_{,\obk{#2}}}
\newcommand{\nprojfst}[2]{\oprojection{\shortleftarrow}{#1}\,#2}
\newcommand{\nprojsnd}[2]{\oprojection{\shortrightarrow}{#1}\,#2}
\newcommand{\simplex}[1]{\scalebox{1}[1.4]{\ensuremath{\rhd}}_{\catN{#1}}}
\newcommand{\simplexfunct}[1]{\wrpfunct{\simplex{#1}_{,}}}
\newcommand{\simplexcat}[1]{\wrpcat{\simplex{#1}_{,}}}
\newcommand{\simplexcat}[1]{\wrpcat{\simplex{#1}_{,}}}
\newcommand{\simplexnn}{\scalebox{1}[1.4]{\ensuremath{\rhd}}_{\mathbb{N}}}

\newcommand{\snat}{\mathpzc{Nat}}
\newcommand{\smallnat}[2]{\snat\cpr{#1}{#2}}
\newcommand{\smallnatobj}{\wrpcat{\smallnat}}
\newcommand{\smallnatnat}{\wrpnat{\smallnat}}
\newcommand{\smallnatfunct}{\wrpfunct{\smallnat}}
\newcommand{\snatfunct}[2]{\wrpfunct{\smallnat{#1}{#2}}}
\newcommand{\snatnat}[2]{\wrpnat{\smallnat{#1}{#2}}}
\newcommand{\snfunct}[1]{\nfunctscr_{\obk{#1}}}
\newcommand{\snfunctdom}[1]{\oper{dom}\,\nfunctscr_{\obk{#1}}}
\newcommand{\snfunctcod}[1]{\oper{cod}\,\nfunctscr_{\obk{#1}}}
\newcommand{\snfunctobj}[1]{\nfunctscr_{\obk{#1},\subp{2}}}
\newcommand{\snfunctarr}[1]{\nfunctscr_{\obk{#1},\subp{3}}}

\newcommand{\chom}[1]{\left|\carr{#1}\right|}
\newcommand{\homobj}[1]{\wrpobj{\chom{#1}}}
\newcommand{\homarr}[1]{\wrparr{\chom{#1}}}
\newcommand{\projg}[3]{\xslantmath{\mathbf{#1}}^{#3}(\mathsf{#2})}
\newcommand{\ccpairn}[2]{\nprojection{#1}(\parsecat{#2})}
\newcommand{\ccpair}[1]{\nprojection{1}(\parsecat{#1})}
\newcommand{\ccpairg}[1]{\nprojection{1}(\mathsf{#1})}
\newcommand{\apair}[2]{\langle\arr{#1},\,\arr{#2}\rangle}
\newcommand{\epair}[2]{\langle|\obk{#1},\,\obk{#2}|\rangle}
\newcommand{\ffpair}[2]{\langle\!\langle\obk{#1},\,\obk{#2}\rangle\!\rangle}
\newcommand{\fpair}[2]{\langle\obk{#1},\,\obk{#2}\rangle}
\newcommand{\fopair}[2]{\langle #1,\,#2\rangle}
\newcommand{\pair}[2]{(#1,\,#2)}
\newcommand{\cpair}[2]{(\obk{#1},\,\obk{#2})}
\newcommand{\cpr}[2]{(\pazocal{#1},\,\pazocal{#2})}
\newcommand{\ctpair}[4]{(\pair{#1}{#2},\,\pair{#3}{#4})}
\newcommand{\ccrel}[2]{\parsecat{#1}_{\obk{#2}}}
\newcommand{\csub}[2]{#1\lessdot #2}
\newcommand{\carrn}[2]{\parsecat{#1}_{\overset{#2}{\rightarrow}}}
\newcommand{\carrnobj}[2]{\wrapobj{\carrn{#1}{#2}}}
\newcommand{\carrnarr}[2]{\wraparr{\carrn{#1}{#2}}}
\newcommand{\carr}[1]{\parsecat{#1}_{\rightarrow}}
\newcommand{\carrobj}[1]{\carr{#1}_{\subp{,\,0}}}
\newcommand{\carrarr}[1]{\carr{#1}_{\subp{,\,1}}}
\newcommand{\functscr}[1]{\small\xslantmath{\pazocal{#1}}}

\newcommand{\bfunct}[1]{\functscr{F}_{\parsecat{#1}}} % behavior
\newcommand{\bfunctobj}[1]{\functscr{F}_{\parsecat{#1},\subp{0}}} % behavior
\newcommand{\bfunctarr}[1]{\functscr{F}_{\parsecat{#1},\subp{1}}} % behavior

\newcommand{\funct}[1]{\functscr{F}_{\obk{#1}}}
\newcommand{\functobj}[1]{\funct{#1}_{,\subp{1}}}
\newcommand{\functarr}[1]{\funct{#1}_{,\subp{2}}}
\newcommand{\functV}[2]{\funct{#1}(#2)}
\newcommand{\functid}[1]{\oper{id}_{\parsecat{#1}}}
\newcommand{\functdom}[1]{\oper{dom}\funct{#1}}
\newcommand{\functcod}[1]{\oper{cod}\funct{#1}}

\newcommand{\ofunct}[1]{\functscr{F}_{#1}}
\newcommand{\ofunctobj}[1]{\functscr{F}_{#1,\subp{1}}}
\newcommand{\ofunctarr}[1]{\functscr{F}_{#1,\subp{2}}}
\newcommand{\ofunctV}[2]{\ofunct{#1}(#2)}
\newcommand{\ofunctid}[1]{\oper{id}_{#1}}
\newcommand{\ofunctdom}[1]{\oper{dom}\ofunct{#1}}
\newcommand{\ofunctcod}[1]{\oper{cod}\ofunct{#1}}

\newcommand{\umpclass}{\mathcal{F}}
\newcommand{\umpclassp}[1]{{\umpclass}_{\parsecat{#1}}}
\newcommand{\umpclasspc}[2]{\umpclassp{#1}(\parsecat{#2})}
\newcommand{\umpall}{\umpclassp{\forall}}
\newcommand{\umpallc}[1]{\umpall(\parsecat{#1})}
\newcommand{\umpconst}[1]{\umpall_{\parsecat{#1}}}
\newcommand{\umpconstc}[2]{\umpconst{#1}(\parsecat{#2})}
\newcommand{\umpcat}{\mathcal{C}}
\newcommand{\umpcatp}[1]{\umpcat_{\parsecat{#1}}}
\newcommand{\umpdomp}[1]{\oper{dom}\,\umpclassp{#1}}
\newcommand{\umpcodp}[1]{\oper{cod}\,\umpclassp{#1}}
\newcommand{\expab}[2]{\obk{#1}^{\obk{#2}}}
\newcommand{\expxab}[2]{\expab{#2}{#1}\times\obk{#1}}
\newcommand{\mapfab}[3]{{#1}:\,{#2}\longrightarrow {#3}}
\newcommand{\mapaob}[3]{{#1}\xrightarrow{\;{#2}\;}{#3}}

\newcommand{\homcat}{\parsecat{Hom}}
\newcommand{\quivercat}[1]{\parsecat{Quiv}(\parsecat{#1})}
\newcommand{\largepo}{\mathbf{\mathpzc{PO}}}
\newcommand{\largeeq}{\mathbf{\mathpzc{EQUIV}}}
\newcommand{\smalleq}{\mathbf{\mathpzc{Equiv}}}
\newcommand{\poset}{\mathbf{\mathpzc{Poset}}}
\newcommand{\largegrf}{\mathbf{\mathpzc{GRF}}}
\newcommand{\smallgrf}{\mathbf{\mathpzc{Grf}}}
\newcommand{\functcat}{\mathbf{\mathpzc{FUN}}}
\newcommand{\functcatcat}{\mathbf{\mathpzc{FUN}}_{\functscr{C}}}
\newcommand{\functcatfunct}{\mathbf{\mathpzc{FUN}}_{\functscr{F}}}
\newcommand{\smallfunctcat}{\mathbf{\mathpzc{Fun}}}
\newcommand{\smallfunctcatcat}{\smallfunctcat_{\functscr{C}}}
\newcommand{\smallfunctcatfunct}{\smallfunctcat_{\functscr{F}}}
\newcommand{\functcatp}[1]{\functcat_{\parsecat{#1}}}
\newcommand{\functcatcatp}[1]{\functcat_{\parsecat{#1},\functscr{C}}}
\newcommand{\functcatfunctp}[1]{\functcat_{\parsecat{#1},\functscr{F}}}
\newcommand{\wrpcat}[1]{{#1}_{\functscr{C}}}
\newcommand{\wrpfunct}[1]{{#1}_{\functscr{F}}}
\newcommand{\wrpnat}[1]{{#1}_{\functscr{N}}}
\newcommand{\largecat}{\mathbf{\mathpzc{CAT}}}
\newcommand{\largecatobj}{\wrpobj{\largecat}}
\newcommand{\largecatarr}{\wrparr{\largecat}}
\newcommand{\smallcat}{\parsecat{Cat}}
\newcommand{\smallcatobj}{\wrpobj{\smallcat}}
\newcommand{\smallcatarr}{\wrparr{\smallcat}}
\newcommand{\expcat}{\mathpzc{Exp}}
\newcommand{\setcat}{\mathpzc{Set}}
\newcommand{\smallsetcat}{\parsecat{set}}
\newcommand{\fincat}{\parsecat{Fin}}
\newcommand{\forgetful}[1]{|#1|}
\newcommand{\forgetgrf}[1]{\functscr{U}(#1)}
\newcommand{\rffunct}{\functscr{U}^{\Circlearrowright}}
\newcommand{\rforgetgrf}[1]{\rffunct(#1)}
\newcommand{\ffunct}{\funct{U}}
\newcommand{\subcat}[1]{\mathpzc{Sub}\parsecat{#1}}

\newcommand{\rquiver}[1]{\parsecat{Q}^{\Circlearrowright}(\mathsf{#1})}
\newcommand{\wquiver}[1]{\parsecat{Q}(\mathsf{#1})}
\newcommand{\nwquiver}[2]{\parsecat{Q}^{#1}(\mathsf{#2})}
\newcommand{\quiver}[1]{\Gamma(\mathsf{#1})}
\newcommand{\graph}[1]{\mathsf{#1}}
\newcommand{\graphv}[1]{\mathsf{#1}_{\mathbf{v}}}
\newcommand{\graphe}[1]{\mathsf{#1}_{\mathbf{e}}}
\newcommand{\graphfree}[1]{\parsecat{C}(\graph{#1})}
\newcommand{\graphclass}[1]{{\mathcal{F}}\,(\graph{#1})}

\newcommand{\evalxab}[2]{\mapaob{\expxab{#1}{#2}}{\oper{eval}}{\obk{#2}}}

\newcommand{\di}[1]{\boldsymbol #1}
\newcommand{\dI}{\boldsymbol \imath}

\newcommand{\freefunct}{{\raisebox{.1\baselineskip}{\ensuremath{\digamma}}}}
\newcommand{\freeset}[1]{\freefunct(#1)}
\newcommand{\pset}[1]{{\raisebox{.15\baselineskip}{\Large\ensuremath{\wp}}}(#1)}
\newcommand{\scard}[1]{\kappa(#1)}

\newcommand{\numchars}[1]{\noindent The string #1 has \StrLen{#1} characters. }

%\newcommand{\hmult}{\scalebox{.4}{\bigtriangledown}}
\newcommand{\cohopfmult}{\scalebox{.6}[1]{\ensuremath{\Delta}}}
\newcommand{\hopfmult}{\raisebox{\depth}{\scalebox{.6}[-1]{\ensuremath{\Delta}}}}

\makeatletter
\def\instring#1#2{TT\fi\begingroup
  \edef\x{\endgroup\noexpand\in@{#1}{#2}}\x\ifin@}
%
\def\isuppercase#1{%
  \ensuremath{%
  \instring{#1}{AÃ‚BCÃ‡DEFGÄžHIÄ°ÃŽJKLMNOÃ–Ã”PRSÅžTUÃœÃ›VYZ}%
  }
}%
\makeatother

\newcommand{\checkcat}[1]{
\StrBefore[1]{#1}{/}[\Topcat]
\StrBehind[1]{#1}{/}[\Botcat]
\StrLen{\Topcat}[\toplen]
\StrLen{\Botcat}[\botlen]
\IfEq{\toplen}{0}{\mathbf{\mathpzc{#1}}}{(\parseonecat{\Topcat}/\parseonecat{\Botcat})}
}

\newcommand{\UpperCats}{ABCDEFGHIJKLMNOPQRSTUVWXYZ}

\newcommand{\parsecat}[1]{%
    \StrLen{#1}[\slen]
    \ifcase\slen
      #1
    \or\parseonecat{#1}
    \else
      \checkcat{#1}
    \fi
}

\newcommand{\parseonecat}[1]{
  \IfInteger{#1}{\catN{#1}}
    { \IfSubStr{\UpperCats}{#1}{\pazocal{#1}}{\obk{#1}} }
}

%\newcommand{\catcaseset}[1]{
%\if\isuppercase{#1}\cat{#1}\else\obk{#1}\fi
%}

\def\CircleArrowleft{\ensuremath{%
  \reflectbox{\rotatebox[origin=c]{180}{$\circlearrowleft$}}}}
\def\CircleArrowright{\ensuremath{%
  \reflectbox{\rotatebox[origin=c]{180}{$\circlearrowright$}}}}
\def\Circlearrowleft{\ensuremath{%
  \rotatebox[origin=c]{100}{$\circlearrowleft$}}}
\def\Circlearrowright{\ensuremath{%
  \rotatebox[origin=c]{150}{$\circlearrowright$}}}

\setcounter{secnumdepth}{4}

\titleformat{\paragraph}{\normalfont\normalsize\bfseries}{\theparagraph}{1em}{}
\titlespacing*{\paragraph}{0pt}{3.25ex plus 1ex minus .2ex}{1.5ex plus .2ex}

\tikzset{
commutative diagrams/.cd,
%row sep=3cm,
%column sep=3cm,
%matrix scale/.style={/tikz/matrix xscale=3,/tikz/matrix yscale=3},
%matrix scale=2,
arrow style=tikz,
diagrams={>=latex}
}
\tikzset{res/.style={ellipse,draw,minimum height=0.1cm,minimum width=0.1cm}}

\begin{document}
\title{Algebra in Category Theory}
\author         {Wolfgang Kraske}
\email        {wolfkden@gmail.com}
\homepage     {http://www.oviumzone.com}
\affiliation  {OVium Studies in Physics}
\date{\today}

\begin{abstract}

\scalebox{.5}{\ensuremath{\bigtriangleup}}
$\hopfmult\cohopfmult\umpclass_{\cohopfmult}\funct{\cohopfmult}\vartriangle\triangle\nabla\Delta\bigtriangleup\umpclass_{\catN{1}}\singletoncat{C}+\rangle\gtrplus\gtrdot\succ$
$\meet\join\top\bot\Mu\mu\mathbf{\mathsf{M}}\mathsf{M}\mathbf{M}\mathrm{M}\mathsf{T}{\Large\mathsf{T}}$

$\Omega\mho{\Large\ensuremath{\varkappa}}\Xi\mathscr{\Xi}$
%{\fontencoding{T1}\fontfamily{calligra}\selectfont the font is temporarily changed}

$\small\xslantmath{\pazocal{F}}}\small\xslantmath{\pazocal{U}}}\small\xslantmath{\pazocal{G}}}\digamma\freeset{G}\freefunct$

$\pazocal{P}\mathcal{P}\mathsf{P}\mathfrak{P}\mathscr{P}\euscr{P}
\pazocal{N}\mathcal{N}\mathsf{N}\mathfrak{N}\mathscr{N}\euscr{N}$

$\circlearrowleft\circlearrowright$
$\CircleArrowleft\CircleArrowright$
$\parsecat{C}^{\small\Circlearrowleft}\parsecat{C}^{\small\Circlearrowright}$
$\rquiver{G}$

% {\fontencoding{T1}\fontfamily{calligra}\selectfont the font is temporarily changed}

%  $\pazocal{G}\pazocal{H}\pazocal{C}\pazocal{P}\pazocal{p}$
  
%  $\mathcal{G}\mathcal{H}\mathcal{C}\mathcal{P}$
  
%  $\mathfrak{G}\mathfrak{H}\mathfrak{C}\mathfrak{P}\mathfrak{p}$
  
%  $\mathscr{G}\mathscr{H}\mathscr{C}\mathscr{P}\mathscr{p}$
  
%  $\mathsf{G}\mathsf{P}\mathsf{p}$
  
%  $\classscr{G}\classscr{P}\classscr{p}$
  
%  $\mathbf\euscr{G}\mathbf\euscr{P}\mathbf\euscr{p}$

  As a foundation of functional programming, category theory is
  an indispensible catalyst for the reliable 
  implementation, execution and analysis of computer algorithms.
  Category theory provides an essential framemork for algorithms
  that support critical or casual activities in contemporary civilization.
  Efficient lambda algorithms now empower
  popular and traditional programming languages;
  developed from the algebra and concepts of category theory.
  Category theory provides essential models and 
  programming idioms based on fixed point theory, Lambek's Theorem,
  to develop recursive algorithms and reifying algebraic structure.
  Many models and idiomatic concepts flourish.
  The structural caveat of Cartesian closed category 
  dictates the design and implementation of programming languages.
  The expression of Yoneda's Lemma in category theory
  facilitates new algorithmic
  representation of problems in physics and real number systems.
  Computer analysis increasingly embraces abstract topics in topology,
  geometry and number theory.
  Topos theory now underpins algorithms for intuitive logic and topology;
  eliminating the need for rigidly inefficient, awkward
  and limited alternatives by outdated set theoretical approaches.
\end{abstract}

\maketitle

\setlength{\parindent}{0em}
\setlength{\parskip}{0.5em}
\renewcommand{\baselinestretch}{1.0}

\section{Introduction}
%$\parsecat{0}$\par
%$\parsecat{1}$\par
%$\parsecat{C}$\par
%$\parsecat{Cat}$\par

Category theory emerged as a schematic representation of
algebraic topology in the late 1940's, quickly progressing
to other fields of mathematics therafter.
In topology category theory eliminated the tedium of point set
analysis for cleaner yet more complete development and proofs.
The introduction of topos theory by Grothendieck,
\cite{grothendieck1957}, with Mac Lane's interpretation in
category theory extended a program of concise analysis to
encompase topology as well as intuitionistic logic.
In the backdrop of decades prior to Mac Lane's 1947 introduction
of category theory, Kurt G\"{o}del's incompleteness theorem overturned the
conjecture of the absolute logical foundation of mathematics and quantum
spin splintered the continuous manifold of phase space,
both concepts are now assimilated into category theory.
G\"{o}del theorem and quantum spin both share the inescapable
reality of fixed point phenomenon in logic and topology.
In support, Lawvere, \cite{lawvere1997}, established the fixed point idiom
within category theory to systematically express parallels in the proof for
Russell paradox, G\"{o}del incompleteness, Cantor cardinalities,
Turing halting, Tarski truth and periphrially the conundrum of quantum spin.
The progenitors, Eilenberg and Mac Lane, developed a categorical firmament to
distill and analyze abstract concepts from the once independent fields
of topology and algebra. The capacity of category theory
to distill concepts and methodology from many fields became
elevated a discipline affecting new fields such as formal language.
The eventuality of these accomplishments propelled
category theory into an independent field of pure mathematics.
Coincidently the field of computer science developed,
underscored by the achievements of Church, Turing and Von Neumann,
as special topic in algebraic topology and as a practical
application for electronic calculating machines.
The ability of category theory to embrace concepts
such as lambda calculus and algebra portend a propitious
future and ongoing fulfillment in computer science and mathematics.
The more recent development of homotopy type theory fully embraces
category theory to combine aspects of algebraic topology, homology and
lambda calculus.

\section{Basic Theory}\label{sec:basictheory}

Category theory develops from definition.
Category theory complements the quantitative
tools of set theory with an emphasis on meta abstraction and
structural frameworks. Meta and general structural frameworks
are mediated by the relational of arrows. In this sense
an entity explicitely or implicitely assumes an arrow, othewise
called relation, to a meta context in a larger category.
Teleological conundra and complexities are implicitly partitioned and
abstracted away from areas of specific interest for construction and analysis.

The redound of Lawvere with Kreisel exposed the greater prospect of
category theory over set theory. This debate
harkens an emergent contention between foundational aspects of
category theory over set theory in mathematics.
As put forth by Lawvere, \cite{lawvere1965},
the elementary theory of the category of sets, ETCS,
argues the involvement of set theory as an aspect
of category theory. The potential exploration of
category theory without the encumberance of set
theory is an ongoing research activity.
Pragmatically, many algebra, computer science and
even category theory texts travail with the formalities of
set theory, genuflecting a strict reference
as a preliminary to the detail of category theory.
Development herein facilitate a symbiotic progression of
category theory intertwined with subordinate aspects of set theory.
In particular, category theory supports qualitative abstraction,
intuitive logic and meta structure whereas set theory provide a
measured quantifiable approach to development.

Although, foundations of category theory originate from the
mid 20\textsuperscript{th} century only recent mathematical
challenges enlist a greater adherence.
As such, set theory and category theory progressively convolve into
complementary disaplines to contribute cooperatively toward
topological, logical and Kripke systems.
Proofs and developments with category theory support
powerful abstractions within an inductive ontology.

Category theory embraces and abstracts the concept of
collection with arrow relations. Extending the strict form of a collections
from set theory.
The collection, also called a, $0-category$, upholds the strictures of
various mathematical disciplines including computer science.
As a meta construct collections are distinguished
by an identity or label. In a more robust context collections
embrace greater expression
with higher order category structure and the broader admission of
proper classes from Von Neuman-Bernays-G\"{o}del, NGB set theory
and more specific cardinal and ordinal measures from
Zermelo-Frankel (ZF) set theory. Proper classes are developed
here as a meta construct, essentially an abstract collection
attributed by a quantifiable collection of properties.

\begin{definition}{Collection}\label{def:collection},
  alternately designated as $0-category$, everything is a collection.
  Collections are attributed as follows:
  \begin{itemize}
  \item\textbf{(Property)} a meta attribute of a collection
  \item\textbf{(Characteristic)} a collection of properties
    attributed to a collection
  \item\textbf{(Arrow)} a directed association from a domain
    collection to a referent codomain collection:
    \begin{itemize}
    \item\textbf{(Domain)} the binding for an arrow
    \item\textbf{(Codomain)} the referent of an arrow
    \item\textbf{(Relation)} an implicit or explicit
      characteristic of an arrow directed from domain to codomain.
      The collection of all relations is designated, $\mathcal{R}$
    \item\textbf{(Membership, $\in$)} An arrow, $\in$, the domain of
      membership is a member to the referent collection. denote as
      {\bf object} the member of a referent collection.
      \begin{itemize}
      \item\textbf{(Object)} a member collection of a referent collection
      All members of a collection are generally refered to as objects.
      \item\textbf{(Empty Collection, $\varnothing$)} a collection without
      member objects
      \end{itemize}
    \item\textbf{(Subcollection, $\lessdot$)} A subcollection
      arrow, $\lessdot$, directs from a subcollection to a referent collection,
      a subcollection consists only of members that are members of the
      referent collection. The empty collection, $\varnothing$, is a
      subcollection of all collections
    \item\textbf{(equivalence, $\sim$)} both domain and codomain
      share a characteristic attribute
    \item\textbf{(equal, $=$)} complete property equivalence of
      domain and codomain,
      a self referent arrow; (1) all collections are self
      referent subcollections (2) the identity arrow of any object
    \item\textbf{(identity arrow, $\arrid{o}$)}, is a self referent
      arrow for any distinct object, $\obk{o}$:
    \begin{itemize}
      \item $\obk{o}=\obk{o}$
      \item $\obk{o}=\arrid{o}(\obk{o})$
    \end{itemize}
    \end{itemize}
  \end{itemize}
\end{definition}

Collection concepts apply to functional and object oriented programming.
In a practical context the abstraction
of collection identity supports lazy instantiation
of program constructs and computer resource management.
In complement, Mac Lane, \cite{maclane1998}, introduced the
the concept of meta-categories prior to penetrating set
and more specific category definitions. Reflexively, category
theory admits and partitions meta concepts in complement
with specific concomitant definitions.
The prefered symbol here, $\lessdot$, indicates a broader subcollection relation
rather than the more specific traditional set operator symbol, $\subset$.
A collection stands as a particular category, the $0-category$,
hence a the more general category symbol, $\lessdot$,
extends to the broader relation of subcategory
associated with higher order categories.

The arrow is a key attribute of category theory which
extends the concept of a set theory relation.
In retrospect, a set theory relation defines an association between
collections of objects whereas the arrow of category theory is attributed
with a relation, domain and codomain objects.
Category theory concerns $n^{th}$ order arrows,
where $n$ is a nonnegative integer.
A $0^{th}$ order arrow is an object with no arrow arributes.
A higher order, $n^{th}$ order arrow, designated with an integer $n>0$,
is attributed with a doamin and codomain arrow of $n-1$ order,
hence a $0^{th}$ order arrow has no domain or codomain attributes.
A $0^{th}$ order arrow is not a relation, rather it is attributed with
a characteristic and membership.
A repetoir of arrows with special attributes support category theory.
In particular, the identity arrow attibutes a designation of a object.
The identity arrow is essential for determination of the existence of an
objects within a collection. The identity arrow is an exclusive self referent
arrow with identical domain and codomain objects.
In context an identity arrow existentially exposes the referent
object as a member or, "undefined" relative to a distinct collection.

The compositional properties of arrows supports a variety of
idiomatic constructs such as commuting diagrams. A diagram is the
most general construction with arrows and objects.
A diagram is essentially a directed graph with arrows for edges
and a referent pair of vertices for each edge. Isolated edges
are associated with self referent arrows or or no arrows.

\begin{definition}{Diagram, $\diag{D}$},\label{def:diagram}
  is a collection of arrows, $\diagarr{D}$ of uniform order.
  The diagram object collection,
  $\diagobj{D}$, consists of the domain and codomain object for each arrow
  in the collection $\diagarr{D}$.
  Isololated objects in the collection, $\diagobj{D}$, are not equivalent to
  any collection arrow domain or codomain objects.
\end{definition}

\begin{definition}{Path, $\diag{P}$,}\label{def:path}
  is a collection of arrows.
  Each arrow in the path has a unique domain object relative to $\diag{P}$
  arrows and likewise unique codomain object relative to $\diag{P}$ arrows.
  The initial arrow of the path has a domain object inconsistent with codomain
  objects of $\diag{P}$ arrows.
  The terminal arrow of the path has a codomain object inconsistent with domain
  objects of $\diag{P}$ arrows.
  Arrows that are not initial share a domain with the codomain of one other
  arrow in the path.
  Arrows that are not terminal share a codomain with the domain of one other
  arrow in the path.
  The domain of the path, $\diagdom{P}$, is a domain object of the
  initial arrow. The codomain of the path, $\diagcod{P}$,
  is a codomain object of the terminal arrow. A trivial path has no arrows.
\end{definition}

\begin{definition}{Cycle, $\diag{C}$},\label{def:cycle}
  A simple cycle is an arrow with identical domain and codomain,
  otherwise a cycle consists of two paths each with unique arrows,
  the domain of one path is the codomain of the alternate path.
\end{definition}

\begin{definition}{Commutative Diagram, $\diag{D}$}\label{def:commutative}
  consists of a collection of paths
  sharing a common domain, $\diagdom{D}$, and codomain,
  $\diagcod{D}$. The paths commute
  or are equivalent from the common domain to the common codomain.
\end{definition}

Algorithms are diagrams that attended to the transformation of
structured domain to codomain objects.
Algorithm behavior is attributed by diagram arrows.
The transformational and compositional characteristic of arrows
establish algorithms properties such as recursion.
A recursive algorithm employed below defines ordinals
wherein the domain and codomain of an arrow are collections
that share similar members except for new constructions.
Finite and ad infinitum principles of recursion imply principles of
induction and the ultimate postulation of the natural number collection.
A simple ordinal algorithm employs the membership arrow, $\in$, with
an initial object, the trivial object defined as the empty collection.
The empty collection, $\varnothing$, although nothing is a singular
concept useful to initiate
a counting algorithm based on the membership arrow, $\in$.
Each iteration of the algorithm generates a new collection
structured on the collection of ordinals from prior iterations.
Structurally, $\varnothing$, or the empty $0-tuple$ $()$, as an initial object
is always an embeded member of subsequent collections;
$\varnothing$, is the unique collection without membership objects. 
The recursive arrow is designated, $\arr{succ}$.
Repeated application of, $\arr{succ}$, sequencially generates
the ordinals inductively.
Algorithmically the concept of ordinals are defined
and assigned isomorphiclly to a collection of symbols,
$\mathbb{N}$, or to arbitrary objects to form $n-tuple$.
An algorithm similarly developed in NGB set theory.
Sequentially each ordinal is succeeded
by the arrow, $\arr{succ}$. The arrow $\arr{val}$
is defined if ordinal $m$ is succeeded by ordinal $n$:

\begin{definition}{$Ordinals$}\label{def:ordinals}
\begin{equation*}\label{eq:ordinal}
  \begin{array}{llll}
    \quad\bullet&\quad()&\thicksim&\;\text{nullary}\quad
                         tuple\quad\text{or}\quad 0-tuple \\[3pt]
    \quad\bullet&\quad\oper{succ}&\thicksim&\;
                  \text{algoritmic ordinal generation:} \\[5pt]
  \quad&\qquad 0&=&\arrn{succ}{0}()=\varnothing \\[3pt]
  \quad&\qquad 1&=&\arr{succ}()=\{\varnothing\} \\[3pt]
  \quad&\qquad
    n&=&\arrn{succ}{n}() = \{\varnothing,\,\arrn{succ}{n-1}()\} \\[3pt]
  \quad&\qquad n&=&\arrn{succ}{p+q}()=\arrn{succ}{p}(\arrn{succ}{q}()) \\[3pt]
  \quad\bullet&\quad\oper{val}&\thicksim&\text{ordinal comparison} \\[3pt]
  \quad&\arr{val_m}(0) &=& \left\{\begin{array}{ll}
                  0 &\quad m=0 \\[3pt]
                  undefined &\quad otherwise
                \end{array} \\[3pt]
  \quad&\arr{val_m}(n) &=& \left\{\begin{array}{ll}
                  m & n=m \\[3pt]
                  \arr{val_m}(0) & n=0 \\[3pt]
                  \arr{val_m}(n-1) & \quad
                \end{array}
\end{array}
\end{equation*}
\end{definition}

Definition, \ref{def:ordinals}, elaborates an algorithm which is also
a specialized arrow that recursively generates the ordinals.
The arrow, $\arrn{succ}{n}$, generates a collection of all ordinals
$\mathbb{N}$, by propositon:

\begin{proposition}{Principle of Induction},
  $0=\arrn{succ}{0}()\in\mathbb{N}$, then
  $\mathbb{N}$ is the natural numbers if:
  \begin{equation*}
  \begin{array}{rll}
  n=\arrn{succ}{n}()\in\mathbb{N}&\Rightarrow&
  n+1=\arr{succ}(n)\in\mathbb{N} \\[3pt]
 &&\quad\text{for all}\quadn\in\mathbb{N} \\[5pt]
  \text{or}\qquad&& \\[5pt]
  m=\arrn{succ}{m}()\in\mathbb{N}&&\text{for all}\quad m=\arr{val_n}(m) \\[3pt]
  &\Rightarrow&\arrn{succ}{n}()\in\mathbb{N}
      \quad\text{for all}\quad n\in\mathbb{N}
  \end{array}
  \end{equation*}
\end{proposition}

The ordinals are a special collection however many objects other than
ordinals may be derived from other types of algorithms and associations
of the observable universe. Selection of any object from a universal collection
manifests from an appropriate identity arrows. The independent selection
of any subcollect collection of objects from the universal collection
upholds the axiom of indeterminancy. Maintaining the order of
each object selectioned is represented by the tuple abstraction.
The tuple consists of an ordered sequence of not necessarily distinct
objects, $(\obk{o}_1,\cdots,\,\obk{o}_n)$:

\begin{equation}\label{eq:tuple}
  \begin{array}{lll}
  \quad\bullet &\quad&\text{Algoritmic generation of an}\quad n-tuple \\
    t_0&=&() \\[3pt]
    t_n&=&(t_{n-1},\obk{o}_n)=(\obk{o}_1,\cdots,\,\obk{o}_n) \\[3pt]
    \quad\bullet &\quad&\text{Algoritmic evaluation of}\;n-tuple\;
                         \text{arity} \\[3pt]
  \oper{ar}(t_n) &=& \left\{\begin{array}{ll}
                  0 & n=0 \\[3pt]
                  n=\{\varnothing,\oper{ar}(t_{n-1})\} & otherwise
                \end{array} \\[3pt]
  \quad\bullet &\quad&n-tuple\;\text{component projection} \\[3pt]
  \pi_m(t_1) &=& \left\{\begin{array}{ll}
                  \obk{o}_1 & m=1 \\[3pt]
                  undefined & otherwise
                \end{array} \\[3pt]
  \pi_m(t_n) &=& \left\{\begin{array}{ll}
                  \obk{o}_m & m=n \\[3pt]
                  \pi_m(t_{n-1}) & \quad
                \end{array}
\end{array}
\end{equation}

The algorithm arrow for the tuple distinctly identifies objects
by order in the tuple. Order identification is necessary since
the specific comparison of the objects is not known.
As such duplicate objects in the tuple collection are possible.
The ordered $n-tuple$ and unordered $n-bag$ collections
support the basis of higher order constructs.
Independent selection of objects from any collection
is a basis for the axiom determinancy used in ZF set theory
to navigate self referential paradoxes such as the the
Banach-Tarski paradox.

\begin{definition}{$n-tuple$}\label{def:tuple},
  $(\cdots)$, is a collection of objects with an arity property,
  $\oper{ar}$, designation of the number, $n\in\mathbb{N}$,
  not necessarily distinct objects.
  A collection of arrows discriminate objects,
  such that, $\pi_i$, discriminates the i\textsuperscript{th}
  object in the $n-tuple$ if $\arr{val_i}(n)=i$.
  The trivial or nullary tuple, $()$, consists of no objects.
  An $n-tuple$ is an object.
  \begin{equation*}
    \begin{array}{ll}
      \quad\bullet\quad&\oper{ar}(\obk{o}_1\cdots\obk{o}_n)=n\in\mathbb{N}
                         \text{,}\quad\oper{ar}()=0 \\
      \quad\bullet\quad&\{\pi_1,\cdots,\pi_n\}\quad
      \text{the collection of arrows} \\
      \quad&\quad\text{discriminating ordered}
             \quad n-tuple\quad\text{objects} \\
    \quad\bullet\quad&\obk{o}_i=\pi_i(\obk{o}_1\cdots\obk{o}_n)
        \quad\text{where}\quad\arr{var_i}(n)=i
    \end{array}
  \end{equation*}
  Pair is a $2-tuple$, with specific arrows, 
  $\oper{fst}=\pi_1$ and $\oper{snd}=\pi_2$: 
  \begin{equation*}
    \begin{array}{lllll}
    \quad\bullet\quad&\obk{a}&=&\oper{fst}\cpair{a}{b}
    \quad&\text{The first member of the pair} \\[3pt]
    \quad\bullet\quad&\obk{b}&=&\oper{snd}\cpair{a}{b}
    \quad&\text{The second member of the pair}
    \end{array}
  \end{equation*}
\end{definition}

 \begin{definition}{$n-ary$ Operators}\label{def:n-ary}
  An arrow renders a natural pair, $2-tuple$, with domain and codomain.
  Alternately, a general algorithm, eq. \ref{eq:tuple},
  provides a rendering of an $n-tuple$ from entry of arbitrary objects.
  Operators are arrows from a domain tuple to a codomain object.
  Each operator has an arity propery that must match the arity
  of the domain tuple to assign a codomain object.
  Several operator arities are extensively applied,
  given general operators, $\oper{c}$, $\oper{u}$, $\oper{b}$,
  with arities, $\oper{ar}(\oper{c})=0$, $\oper{ar}(\oper{u})=1$,
  $\oper{ar}(\oper{b})=2$,
  and objects, $\obk{o}$, $\obk{r}$, $\obk{s}$, $\obk{t}$:

  \begin{equation*}
    \begin{array}{ll}
      \quad\bullet\quad&\mathbf{(Nullary)}\quad\oper{c}=\obk{o},
                         \;\oper{ar}(\oper{c})=0\text{,} \\[3pt]
                  \quad&\text{an arrow that maps the nullary} \\[3pt]
                  \quad&\text{trivial tuple to a singular object,} \\[3pt]
                  \quad&\text{a constant mapping} \\[3pt]
      \quad\bullet\quad&\mathbf{(Unary)}\quad\oper{u}(\obk{r})=\obk{o},
                         \;\oper{ar}(\oper{u})=1\text{,} \\[3pt]
                  \quad&\text{an arrow that maps a unary tuple} \\[3pt]
      \quad&\text{to a singular object,} \\[3pt]
      \quad&\text{shorthand notation:}\quad\obk{r}^{\oper{u}}=\obk{o} \\[3pt]
      \quad\bullet\quad&\mathbf{(Binary)}\quad\oper{b}\cpair{s}{t}=\obk{o},
                         \;\oper{ar}(\oper{b})=2\text{,} \\[3pt]
                  \quad&\text{an arrow that maps a pair, binary} \\[3pt]
                  \quad&\text{tuple, to a singular object,} \\[3pt]
                  \quad&\text{shorthand notation:}
                                \;\obk{s}\,\oper{b}\obk{t}=\obk{o}
    \end{array}
  \end{equation*}  
\end{definition}

The $n-tuple$ proves a algorithmic methodology for constructing
collections rather than an relying on an analytical approach to
analyzing collections.

A collection can be identified by qualifiable properties of members
without the quantifiable membership relevant to set theory.
This approach supports contingencies where the discrimination
or enumeration of collection members may not be realizable or
interesting for analysis or representation.
Conundra of quantum mechanics are repleat with examples,
such as the individuation of collection members
permenantly alters the properties of members and the collection.
Explicit property names, such as membership,
are used in the text with an implicit assumption of arrow.

In general a category consists of a pair of collections,
a collection of objects and a collection of arrows.
Arrows are a powerful construct, mediating the structure of the
object collection and supporting property definitions. Alternate 
developments use the term morphism rather than arrow.
This text uses the arrow terminology to conform with
the functional programming languages such as Haskell.
Initially, arrow applications are  first order limited to
relations between objects. First order categories are refered
to as $1-category$, however higher order relations between arrow structures
are introduced in later sections. By assumption all categories
are assumed as $1-category$ unless specifically stated.

An arrow is directed within the category from an object,
the domain, to an object, the codomain.
The domain and codomain objects may be the same
object or distinct objects, equivalently a pair.
Each object in a category has a unique identity arrow.
Identity arrows are alternately denoted as as trivial arrows or
trivial morphisms. Each object of a category assumes an identity arrow
by definition.

\begin{definition}{Category, $1-category$}\label{def:category},
  $\parsecat{C}$, is a structured collection characterized by
  a pair of distinct collections,
  identifed by properties, $\oper{obk}$
  and $\oper{arr}$. The operator, $\oper{obk}$, is distinguished
  by the german word, objekt, equivalent to the prosaic english
  term, object:
  \begin{itemize}
    \item $\catobj{C}=\oper{obk}\parsecat{C}$, object collection
    \item $\catarr{C}=\oper{arr}\parsecat{C}$, arrow collection 
  \end{itemize}
\end{definition}

\begin{definition}{Composition Algebra}\label{def:composition},
  each arrow, $\arr{r}\in\catarr{C}$, of a collection, $\parsecat{C}$,
  is a directed association from a
  domain object to a codomain object of $\catobj{C}$.
  The domain and codomain objects are a referent pair of the  arrow,
  $\arr{r}$; designated by properties,
  $\oper{dom}$ and $\oper{cod}$, respectively:
  \begin{itemize}
    \item\textbf{(Domain)}, $\arrdom{r}\in\catobj{C}$, domain object
    \item\textbf{(Codomain)}, $\arrcod{r}\in\catobj{C}$, codomain object
    \item\textbf{(Relation)}, $\arrrel{r}\in\mathcal{R}$, arrow characteristic
    \item\textbf{(Map Notation)}, $\arr{r}:\,\arrdom{r}\rightarrow\arrcod{r}$ \\
      $\qquad$ or $\quad\arrdom{r}\xrightarrow{\;\obk{r}\;}\arrcod{r}$
    \item\textbf{(Composition Algebra)},\\ given arrows,
      $\arr{r}$,$\arr{s}$,$\arr{t}\in\catarr{C}$, where\\
       $\arrcod{r}=\arrdom{s}$ and $\arrcod{s}=\arrdom{t}$
      \begin{itemize}
      \item\textbf{(Binary operator, $\circ$)}
        $\arr{s}\circ\arr{r}=\arr{s\circ r}$,\\
        $\qquad\arrdom{r}\xrightarrow{\;\obk{s}\circ\obk{r}\;}\arrcod{s}$
      \item\textbf{(Associative)}
        $(\arr{t}\circ\arr{s})\circ\arr{r}=\arr{t}\circ(\arr{s}\circ\arr{r})$
      \item\textbf{(Identity)} $\arrid{o}\in\catarr{C}\quad\forall\;
        o\in\catobj{C}$
      \begin{itemize}
        \item\textbf{(Idempotency)} $\arrid{o}\circ\arrid{o}=\arrid{o}$
        \item\textbf{(Composition Identity)} $\forall\;\arr{r}\in\catarr{C}$ \\
        $\arr{r}=\arr{r}\circ\arrid{\arrdom{r}}=\arrid{\arrcod{r}}\circ\arr{r}$
      \end{itemize}
      \end{itemize}
  \end{itemize}  
\end{definition}

To define a category a collection of extrinsic operators
are used to determine subcollections, $\oper{obk}$ and $\oper{arr}$.
To segregate $n^{th}$ order arrows, $n\in\mathbb{N}$,
the operator $\oper{arr}^n$ applies. Likewise $\oper{dom}$, $\oper{cod}$
and $\oper{rel}$ filter attributes from higher order arrows.
Membership, $\in$, is another extrisic operator.
Intrinsic analysis and transformation of categories maintains order
of collections. In particular $n^{th}$ order category arrows map or relate
domain to codomain $n-1^{st}$ order arrows. Hence intrinsic operations
are order preserving and extrinsic operations transform or relate
between orders. Furthermore extrinsic operators act globally with a
specific relation without specific
domain or codomain assignments whereas intrinsic
operators or arrows are defined relations from a specific domain to codomain
object. From this respect a extrinsic operators are members of
a distinct collection from categories.
Categories may further be represented in various context orders.
The $0^{th}$ order context flattens objects to all orders into a $0-category$
whereas the $1^{st}$ order context represents a category with
arrows segregated uniformly into distinct subcollectons associated
with the extrinsic operator, $\oper{arr}^n$.
The section of functors introduces the $2^{nd}$ order cotext.

\begin{figure}[section]
     \begin{tikzpicture}[
            > = stealth, % arrow head style
            shorten > = 1pt, % don't touch arrow head to node
            auto,
            node distance = 3cm, % distance between nodes
            semithick % line style
        ]

        \node[] (A) {$u$};
        \node[] (B) [right of=A] {$v$};
        \node[] (C) [below of=B,right of=D] {$w$};
        \node[] (D) [below of=A] {$x$};
        
        \path[->] (B) edge [] node[below right, pos=.78]
                                {$\arr{h\circ g}$} (D);
        \path[->] (A) edge node {$\arr{f}$} (B);
        \path[->] (B) edge node {$\arr{g}$} (C);
        \path[->] (C) edge node {$\arr{h}$} (D);
        \path[->] (A) edge node[right,pos=.7] {$\arr{g\circ f}$} (C);
        \path[->] (A) edge node[left] {$\arr{h\circ g\circ f}$} (D);
        \path[->] (C) edge [reflexive below]
             node[anchor=center,midway,below] {$\arrid{\text{w}}$} (C);        
        \path[->] (B) edge [reflexive above]
             node[anchor=center,midway,above] {$\arrid{\text{v}}$} (B);        
        \path[->] (A) edge [reflexive above]
             node[anchor=center,midway,above] {$\arrid{\text{u}}$} (A);        
        \path[->] (D) edge [reflexive below]
             node[anchor=center,midway,below] {$\arrid{\text{x}}$} (D);
 %       \draw[red, dashed] (1, 2) -- (1, -2);
      \end{tikzpicture}
      \caption {Arrow identity, composition and assosiative law
        \begin{itemize}
          \item$u=\arrdom{f}$
          \item$v=\arrdom{g}=\arrcod{f}$
          \item$w=\arrdom{h}=\arrcod{g}$
          \item$x=\arrcod{h}$
          \end{itemize}
          Associativity of the binary operator $\circ$
          is diagramatically proven:
          $\arr{h\circ g\circ f}=\arr{h}\circ\arr{g\circ f}
          =\arr{h\circ g}\circ\arr{f}$
        }\label{fig:arrowalgebra}
\end{figure}

Arrow algebra, fig. \ref{fig:arrowalgebra},
with identity, composition and associative properties,
is graphically presented. The associativity of
composition is diagrammatically proven
without complex definitions.
Arrows are a discriminating feature of categories.
The internal structure of a category is mediated by arrows.
Implicit properties of a category are exposed through
analysis of arrows.
Qualitative classification and study of a category
with arrows complement the traditional quantitative
approach of set theory. For instance,
topological characteristics are qualified by arrow abstractions
while eliminating the tedium of point set topology.
The identity arrow of an object acts as an
operator on a collection to distinguish the
associated object in the collection or specify that the
object does not exist in the collection, unknown.
The identity arrow acts existentially to maps the
associated domain object identically to itself. 
An identity arrow applied to a collection yields
the contained object of the identity arrow,
$o=\arrid{o}(\catobj{C})$ when $\obk{o}\in\catobj{C}$,
otherwise the object is not a member of the collection
and the operation is undefined.
Identity behavior is used extensively
in programming. The large category, $\largecat$,
cosists of a large object collection, $\largecatobj$,
and a large arrow collection, $\largecatarr$.
Each object, $\obk{o}\in\largecatobj$, has a unique
identity arrow, $\arrid{o}\in\largecatarr$,
Identity is a special relation of self associated
with each object in $\largecatobj$.

On occasion that only the identiy propery of category objects,
$\ccobj{C}$, is of
interest, the subcolloection of all identity arrows is
denoted as $\ccid{C}\lessdot\ccarr{C}$.

Category and set theory developments regard properties
as simple attributes of relations and classes.
Generally category objects and arrows represent
collections of properties and relations, repspectively.
The category of properties and relations is designated
as a behavior.

\begin{definition}{Behavior}\label{def:behavior},
$\parsecat{B}$, is a category in the class of behaviors,
$\mathcal{B}$. For each behavior, $\parsecat{B}$, the object collection or
characteristic,
$\ccobj{B}$, consists of properties and the arrow collection, $\ccarr{B}$,
consists of relations.
\end{definition}

The formal association of behavior to a category requires
the concept of a mapping from a domain category to a codomain
category. Functor is the name of this concept, 
a category of arrows, developed in later sections.

Conveniently, concepts introduced
herein facilitate computer programming idioms such as object
characterization of memebers to a defined class.
class or type programming supports the instantiation of
objects with common characteristics without necessary reference
to the number of objects existing in an algorithm. 
Objects in the same class are discriminated by identity arrows,
an idiom easily generalized to search algorithms for particular
objects. General search extends to discriminate
subcategories by class relative to a particular properties or
arrow relationship.

Subsequently, a variety of specialized relations
attribute arrow maps from domain to codomain.
Arrow relations of monomorphism, epimorphism and isomorphism
respond with distinct compositional properties.

\begin{definition}{Monomorphism, $\oper{mono}$}\label{prop:monomorphism},
  $\arr{f}\in\catarr{C}$, of category $\parsecat{C}$,
  is a monomorphism, $\oper{monic}$, \\
  for any $\arr{g}$,$\arr{h}\in\catarr{C}$, 
  $\obk{a}=\arrdom{g}=\arrdom{h}$ \\
  and $\quad\arrcod{g}=\arrcod{h}=\arrdom{f}$ \\
  $\qquad\Longrightarrow\arr{f\circ g}=
  \arr{f\circ h}\Rightarrow\,\arr{g}=\arr{h}$
\end{definition}

\begin{center}
     \begin{tikzpicture}[
            > = stealth, % arrow head style
            shorten > = 1pt, % don't touch arrow head to node
            auto,
            node distance = 2cm, % distance between nodes
            semithick % line style
        ]

        \node[] (a) {$\obk{a}$};
        \node[] (d) [right of=a] {$\arrdom{f}$};
        \node[] (c) [right of=d] {$\arrcod{f}$};

        \path[->] ([yshift=1ex]a.east) edge node[above]
                  {$\obk{g}$} ([yshift=1ex]d.west);
                  \path[->] ([yshift=-1ex]a.east) edge node[below]
                  {$\obk{h}$} ([yshift=-1ex]d.west);
        \path[->] (d) edge node {$\obk{f}$} (c);
      \end{tikzpicture}
\end{center}

\begin{definition}{Epimorphism, $\oper{epi}$}\label{prop:epimorphism},
  $\arr{f}\in\catarr{C}$, of category $\cat{C}$,
  is a epimorphism, $\oper{epic}$,
  for any $\arr{g}$,$\arr{h}\in\catarr{C}$ \\
  $\obk{b}=\arrcod{g}=\arrcod{h}$ \\
  and $\quad\arrdom{g}=\arrdom{h}=\arrcod{f}$ \\
  $\qquad\Longrightarrow\arr{g\circ f}=
  \arr{h\circ f}\Rightarrow\,\arr{g}=\arr{h}$
\end{definition}

\begin{center}
     \begin{tikzpicture}[
            > = stealth, % arrow head style
            shorten > = 1pt, % don't touch arrow head to node
            auto,
            node distance = 2cm, % distance between nodes
            semithick % line style
        ]

        \node[] (d) {$\arrdom{f}$};
        \node[] (c) [right of=d] {$\arrcod{f}$};
        \node[] (b) [right of=c] {$\obk{b}$};

        \path[->] (d) edge node {$\obk{f}$} (c);
        \path[->] ([yshift=1ex]c.east) edge node[above]
                  {$\obk{g}$} ([yshift=1ex]b.west);
        \path[->] ([yshift=-1ex]c.east) edge node[below]
                  {$\obk{h}$} ([yshift=-1ex]b.west);
\label{dig:epimorphism}
\end{tikzpicture}
\end{center}

\begin{definition}{Isomorphism, $\oper{iso}$}
  is a reflexive property of a pair of arrows $\pair{\arr{r}}{\arr{r}^{-1}}$
  such that, $\arr{r^{-1}}=\arr{r}^{-1}$:
  \begin{itemize}
    \item$\arrdom{r}=\arrcod{r^{-1}}$ and $\arrdom{r^{-1}}=\arrcod{r}$
    \item$\arr{r}\circ\arr{r^{-1}}=\arrid{\arrdom{r}}$
    \item$\arr{r^{-1}}\circ\arr{r}=\arrid{\arrcod{r}}$
  \end{itemize}
\end{definition}

A pair of isomorphic objects,
$\cpair{a}{b}$ are denoted as $\obk{a}\cong\obk{b}$.

\begin{center}
     \begin{tikzpicture}[
            > = stealth, % arrow head style
            shorten > = 1pt, % don't touch arrow head to node
            auto,
            node distance = 3cm, % distance between nodes
            semithick % line style
        ]

        \node[] (d) {$\arrdom{r}$};
        \node[] (c) [right of=d] {$\arrcod{r}$};

        \path[->] ([yshift=1ex]d.east) edge node[above]
                  {$\arr{r}$} ([yshift=1ex]c.west);
        \path[<-] ([yshift=-1ex]d.east) edge node[below]
                  {$\arr{r^{-1}}$} ([yshift=-1ex]c.west);
      \end{tikzpicture}
\end{center}

Specialized isomorphisms relate distinct characteristics
with the associated object.
An isomorphism is both a
monomorphism and an epimorphism as well as a an
equivalence relation between the domain and codomain.
The alternate is not implied 
when the domain and codomain are categories.
A class of arrows supporting complementary requirements
map catgory domains to category codomains.
A extended class of arrows, functors,
transform a domain category
to a codomain category with complementary behavior
to map the compositional
properties of category arrow collections from domain to codomain.

Endomorphisms are a special relational class of arrows with
identical domain and codomain.
Thus far the identity arrow is a familiar subclass of the endomorphism class.
The identity arrow is also an automorphism which is a special subclass of
isomorhic endomorphisms. Much of the focus on category theory involves
developments with arrows and the more complex extension to functors.
Developments with automorphisms are almost equally interesting.
In particular an single object may support a collection of endomorphisms
or even automorphisms to develop complex algebras.

\begin{definition}{Endomorphism, $\oper{endo}$}\label{def:endomorphism}
  is an arrow with domain and codomain as the same object.
  An automorphism is an isomorphic endomorphism.
  The identity arrow is an unique automorphism for a designated
  domain/codomain object, acting as a self inverse:
\begin{equation*}
\arrid{o}\circ\arrid{o}=\arrid{o}\quad\forall\obk{o}\in\largecatobj
\end{equation*}
\end{definition}

As an example, a row of a
database table is an object with an identity iso for
lookup and property endo's for each field. 

The existential property of an identity arrow upholds
the axiom of choice. Identity arrow provides the ability to
select a specific object from a general collection.

\begin{definition}{Existential Identity Property}\label{def:identitymap}
  The identity arrow, $\arrid{o}$, of a particular object, $\obk{o}$,
  supports the selection of a particular object from a general
  collection. If the object is not found the identity returns undefined.
  functors, $\arrid{o}\in\largecatarr$, for categories
  $\parsecat{C}\in\largecatobj$:
\begin{equation*}
    \arrid{o}(\parsecat{C})=\left\{
                 \begin{array}{ll}
                   \obk{o}=\arrid{\obk{o}}(\obk{o})&\obk{o}\in\ccobj{C} \\[3pt]
                   undefined& otherwise
                  \end{array}
\end{equation*}
\end{definition}

\subsection{Functor}

A functor is a mapping from a domain category to a codomain
category. A functor acts as a generalized arrow to map categories
with an additional fulfillment to map underlying composition
properties from a domain category to a codomain category.
In greater detail, a functor, $\funct{f}$, is a specialized category,
consisting of collections of first and second order arrows
with an arrow collection, $\functobj{f}$, consisting of arrows
that map domain category objects, $\wrapobj{\functdom{f}}$, to
codomain objects, $\wrapobj{\functcod{f}}$,
likewise a functor has a second order arrow collection,
$\functarr{f}$, consisting of arrows that map domain arrows,
$\wraparr{\functdom{f}}$, to codomain arrows, $\wraparr{\functcod{f}}$.
Essentially the arrow collection, $\functobj{f}$, of a functor, $\funct{f}$,
alludes to an object collection of a general category
and the second order arrow collection, $\functarr{f}$, alludes
to an arrow collection of a general category.
The concept of a second order arrow specifies a mapping from
a domain arrow to a codomain arrow.
Abstractly, a functor acts as a specialized arrow with
additional behavior to transform implicit
compositional arrow structure and identites from a domain
category to a codomain category.
The term behavior is reserved in the text to define the mapping
of properties from a domain collection or category to a codomain
collection or category.
A large functor category, $\functcat$, is validated by a collection of
functors, $\functcatfunct$, with the capacity to
support arrow composition and act as identity arrows for
the category collection, $\functcatcat$.
The collection of functors, $\functcatfunct$, further share the same
compositional properties as arrows when domain and codomain
definitions coincide.
The deeper behavior of functors, beyond that of arrows,
assures the enforcement of strict
isomorphic relations from mono and epic relations between categories.
Distinct from Hom UMP,
a functor homomophically translates underlying
category domain objects, arrow identity and
compositional algebra, into a codomain category.

In summary the collection of all functors with relevant domain/codomain
categories forms a large category, $\functcat$.
The large category, $\functcat$, consists of a
functor collection, $\functcatfunct$, supporting the arrow
requirements of a category, and an object collection,
$\functcatcat$, consisting of relevant functor domain/codomain categories.
Each category of $\functcatcat$,
has an unique identity functor acting as specialized identity arrow.

\begin{definition}{Functor category}\label{def:functorcat},
  $\functcat$, consists of the large class, collection, of functors,
  $\mathcal{F}=\functcatfunct$.  
  By definition the functors of, $\funct{F}\in\mathcal{F}$, support
  arrow composition properties,
  def. \ref{def:composition}. The collection
  of all domain/codomain objects of functors in, $\mathcal{F}$,
  form a collection of categories, $\mathcal{C}=\functcatcat$. Each
  category object of the collection, $\parsecat{C}\in\functcatcat$,
  has a unique identity functor, $\functid{C}\in\functcatfunct$. 
\end{definition}

\begin{definition}{Functor}\label{def:functorarrow},
  $\funct{F}\in\mathcal{F}$, is a a category of arrows which
  supports all properties of an arrow, def. \ref{def:composition}.
  As such a functor supports all relevant composition, associativity
  and identity properties from a domain category, $\functdom{F}$,
  to a codomain category, $\functcod{F}$:
  \begin{itemize}
  \item\textbf{(Domain)} $\functdom{F}$ functor domain category
  \item\textbf{(Codomain)} $\functcod{F}$ functor codomain category
    \item\textbf{(Mapping)}
      \begin{equation*}
      \begin{array}{rr}
        \quad & \funct{F}:\,\functdom{F}\longrightarrow\functcod{F} \\[3pt]
        \text{or}\quad & \functdom{F}\xrightarrow{\;\mathbf{F}\;}\functcod{F}
       \end{array}
      \end{equation*}
  \end{itemize}
  Each functor, $\funct{F}\in\mathcal{F}$, is a collection pair with a first
  member, the object collection, $\functobj{f}$, and a second member,
  the arrow collection, $\functarr{f}$. The object collection, $\functobj{F}$,
  consists of arrows that map a domain object collection,
  $\wrapobj{\functdom{F}}$,
  to codomain object collection, $\wrapobj{\functcod{F}}$.
  The functor arrow collection, $\functarr{F}$,
  consist of second order arrows that map a domain arrow
  collection, $\wraparr{\functdom{F}}$, to codomain arrow collection,
  $\wraparr{\functcod{F}}$. The second order arrow collection,
  $\functarr{F}$, contains an identity arrow subcollection
  for each member of, $\functobj{F}$.
  \begin{equation*}
 \begin{array}{llll}
  \quad\bullet\textbf{(Object)}&\wrapobj{\functcod{F}}&=&
                             \{\arr{f}(\obk{o})\hspace{6pt}\mid
                             \arr{f}\in\functobj{F}, \\[3pt]
   &\hspace{16pt}\arrdom{f}&=&\obk{o}\in\wrapobj{\functdom{F}}\} \\[3pt]
  \quad\bullet\textbf{(Arrow)}&\wraparr{\functcod{F}}&=& \\[3pt]
   &\{\oarr{2}{f}(\arr{o})&\mid&\oarr{2}{f}\in\functarr{F}, \\[3pt]
   &\hspace{16pt}\oarrdom{2}{f}&=&\arr{o}\in\wraparr{\functdom{F}}\} \\[3pt]
  \quad\bullet\textbf{(Identity)}&\hspace{24pt}\{\oarrid{2}{f}&\mid& \\[3pt]
      &\oarrid{2}{f}(\arr{f})&=&\arr{f}\,\forall\arr{f}\infunctobj{F}, \\[3pt]
                            &&&\oarrid{2}{f}\in\functarr{F}\,\}
 \end{array}
 \end{equation*}
\end{definition}

% $\functdom{F}\xrightarrow{\;\obk{F}\;}\functcod{F}$
\begin{definition}{Composition Homomorphism}\label{def:functorhomomorphism},
  in addition to arrow properties, \ref{def:functorarrow},
  a functor, $\funct{F}\in\mathcal{F}$\;, has homomorphic
  properties that translate the compositional properties
  of the internal domain collection to the codomain
  collection. A mapping than translates algebraic properties
  from a domain to a codomain is a homomorphism.
  $\forall$ $\obk{a}$, $\obk{b}\in\wrapobj{\functdom{F}}$ and
  $\arr{g}$, $\arr{f}\in\wraparr{\functdom{F}}$:
  \begin{equation*}
 \begin{array}{llll}
  \quad\bullet\;\: & \funct{F}(\mapaob{a}{f}{b}}) &=&
    \functV{F}{a}\xrightarrow{\;\functV{F}{f}\;}\functV{F}{b} \\[3pt]
  \quad\bullet\;\: & \funct{F}(\arrid{a}) &=& \arrid{\functV{F}{a}} \\[3pt]
  \quad\bullet\;\: & \funct{F}(\arr{\obk{g}\circ\obk{f}}) &=&
    \arr{\functV{F}{g}}\circ\arr{\functV{F}{f}}
    =\arr{\functV{F}{g}\circ\functV{F}{f}}
 \end{array}
 \end{equation*}
Where, $\functV{F}{a},\,\functV{F}{b}\in\wrapobj{\functcod{F}}$ and \\
       $\functV{F}{f},\,\functV{F}{g},\,\arr{\functV{F}{g}\circ\functV{F}{f}}\in\wraparr{\functcod{F}}$
\end{definition}

The identity functor of a category exhibits a collections of
first and second order identity arrows useful for later developments.

\begin{definition}{Identity Functor}\label{def:identityfunctor},
  $\functid{C}\in\functcatfunct$,  is identity for a category,
  $\parsecat{C}\in\functcatcat$. A functor identity, $\functid{C}$,
  consists of respective first and second order identity arrow collections,
  $\owraparr{1}{\functid{C}}$, and $\wraparr{\functid{C}}$.
  $\owraparr{1}{\functid{C}}$, is a collection of first order identity arrows
  for the objects of the domain/codomain category, $\ccobj{C}$.
  and, $\owraparr{2}{\functid{C}}$, is a collection of second order
  identity arrows for the first order collections,  $\owraparr{1}{\functid{C}}$,
  and $\ccarr{C}$.
\begin{equation*}
 \begin{array}{llll}
  \quad\bullet\;\: & \owraparr{1}{\functid{C}} &=&
                    \{\arrid{o}\mid\obk{o}\in\ccobj{C}\,\}=\ccid{C} \\[3pt]
  \quad\bullet\;\: & \owraparr{2}{\functid{C}} &=&
                    \{\oarrid{2}{f}\mid\arr{f}=\arrid{o}\in\ccarr{C} \\[3pt]
                    &\text{or}&&
                       \arr{f}\in\wrapobj{\functid{C}}\,\}
 \end{array}
\end{equation*}
\end{definition}

Characteristics are attributed to categories however functors are categories
of arrows with the distinct application of transforming characteristics from
a domain category to a codomain category. Behavior, \ref{def:behavior},
suitably attributes functor transformation of characteristics. 
A behavior functor associates a functor to a respective behavior.

\begin{definition}{Behavior Functor, $\funct{B}$}\label{def:functorbehavior},
a functor mapping associating a functor, $\funct{F}\in\functcatfunct$,
with a behavior category, $\parsecat{B}$. \\[5pt]
\begin{equation*}
\funct{B}(\funct{F})=\parsecat{B}\in\mathcal{B}
 \end{equation*}
\end{definition}

$\largecat$ and $\functcat$ are large categoies.
Only characteristics of general or large categories are
universally mapped since general scope or size are not
feasible or interesting for analysis or construction.
Mappings on categories objects of $\functcatcat$,
are dictated by subclasses of the functor class, $\mathcal{F}$,
Important subclasses of $\mathcal{F}=\functcatfunct$ establish
universal mapping properties, (UMP). Discrete UMP
functor classes globally transform structural
properties on all categories of $\functcatcat$ whereas others
transform subclasses of $\functcatcat$ that share common
functor symmetry and limit properties. 

\subsection{Universal Mapping Property}

Universal mapping property (UMP) characterizes discrete functor classes,
$\umpclassp{B}\lessdot\umpclass=\functcatfunct$, consisting of
functors that share a distinct behavior, $\parsecat{B}$.
A behavior, $\parsecat{B}$, essentially defines a special class
of functors, $\umpclassp{B}$, that map a domain class of categories,
$\umpdomp{B}$, to an associated codomain class of categories, $\umpcodp{B}$.
Each UMP class, $\umpclassp{B}\lessdot\functcatfunct$,
satisfy one or more of three general behaviors:
(1) endomorphic transformation of
specific behavior of the class of categories, $\umpdomp{B}=\umpcodp{B}$,
(2) transform domain categories of, $\umpdomp{B}$, to more
structured property domain classes, $\umpcodp{B}$.
(3) universally limit categories of a domain class,
$\umpdomp{B}$, to a codomain class, $\umpcodp{B}$,
based on associated fuctor symmetries.
Universal mapping properties transform subclasses of categories
with subclasses of functors relative to a behavior.
The prior section involved discrete functor transformation whereas
this section concerns transformation of collections of categories
with collections of functors. The terminology UMP is used in this
text to remain relatant to outstanding category literature however
universal mapping behahavior is a more specific reference.

\begin{definition}{Universal Mapping Property, UMP}\label{def:universalmap}
  is a general collection of functor classes:
\begin{equation*}
  \{\umpclassp{B}\mid
    \umpclassp{B}\lessdot\umpclass,\,
    \bfunct{B}(\funct{F})=\parsecat{B}^{\prime}\in\mathcal{B}\;
    \forall\funct{F}\in\umpclassp{B}\}
\end{equation*}
  where
  $\mathcal{B}$ is a general collection of behaviors.
  $\umpclassp{B}$, a class of functors, $\umpclassp{B}\lessdot\umpclass$,
  that transform
  a behavior, $\parsecat{B}$, of a domain class, 
  $\umpdomp{B}\lessdot\umpcat$, to a codomain class,
  $\umpcodp{B}\lessdot\umpcat$ where $\umpcat=\functcatcat$.
  In general a UMP, $\umpclassp{B}$, transforms a behavior
  $\parsecat{B}$ of a domain class of categories, $\umpdomp{B}=\umpcatp{B}$,
  to a codomain class of categories, $\umpcodp{B}=\umpcatp{B}^{\prime}$,
  with codomain behavior, $\bfunct{B}^{\prime}$. In general a large
  functor property is defined by each UMP:
\begin{equation*}
\begin{array}{lll}
  \functcatcatp{B}&=&\{\parsecat{O}\mid
  \parsecat{O}\in\umpdomp{B}\;\text{or}\;
  \parsecat{O}\in\umpcodp{B}\,\} \\[3pt]
  \functcatfunctp{B}&=&\umpclassp{B}
\end{array}
\end{equation*}
\end{definition}

The unary maps that endomorphically
transform, $\functcatcat$, into itself are easily
definable examples of universal mapping.

Concepts from programming application enter into
the development of mapping properties for functors
and functor classes. Concepts are discussed
in terms of functors but relaxation to
arrows is also assumed.
A universal map is a collection of functors
related by common UMP. In demonstration,
each universal map is a collection of functors
acting on a collection of corresponding
categories. Each functor of the universal
map acts specifically on a particular
category in the assiciated category collection.
Instantiation of an identity map on a category
object instances a specific identity functor
associated with the category object.

A trivial UMP is the identity map which
identically transforms each category in, $\functcatcat$.
The identity UMP, $\umpclassp{id}\lessdot\umpclass$, is a elementary
demonstration of instantiation.
The universal identity mapping, $\umpclassp{id}$, consists of a
subclass of identity functors.
Identity functors are essential in compositional
algebra and in identifying categories with the same
abstract behavior as identity arrows on objects.

\begin{definition}{Identity property}\label{def:identitymap}
  The identity map, $\umpclassp{id}$, is a collection of all identity
  functors, $\functid{C}\in\umpclass$, for categories
  $\parsecat{C}\in\functcatfunct$:
\begin{equation*}
  \begin{array}{lrrl}
    \quad\bullet\;\textbf{(Id Class)}
    &\umpclassp{id}&=&\{\functid{C}\mid
                 \parsecat{C}\in\functcatcat\} \\[3pt]
    \quad\bullet\;\textbf{(Instance)}
       &\umpclasspc{id}{C}&=&\functid{C}
                (\parsecat{C})\quad\forall\;\parsecat{C}\in\functcatcat
  \end{array}
\end{equation*}
\end{definition}

Instantiation is the selection and application
of a functor defined with the designated domain from a
class of functors to the category of definition.
Instantiation requires a unique functor for every
category in the domain of the functor class.

Instantiation is extensible to more transformative
UMP classes of unitary functors. Each functor class
exists as a collection of functors with a common property
transformation of domain objects to codomain objects.
Instantiation is the strategy to define UMP transformation
in the large category context. The strategy extends
from unary to mappings on structured $n-tuple$ or $n-bag$
ordered or unordered collections respectively.

UMP transformation upholds a compositional algebra
familiar to functors and arrows. The concept of
commuting diagrams follows directly:

\begin{definition}{UMP commuting property}\label{def:commuting},
  given the functor class $\umpclass$,
  any composable UMP pair $\umpclassp{f},\,\umpclassp{g}\lessdot\umpclass$
  define commute to a UMP $\umpclassp{h}\lessdot\umpclass$:
\begin{equation*}
\begin{array}{rll}
\umpclassp{h}&=&\umpclassp{g}\circ\umpclassp{f} \\[5pt]
\text{with collection equalities}&& \\[5pt]
\umpdomp{g}&=&\umpcodp{f} \\[3pt]
\umpdomp{h}=\umpdomp{g} && \umpcodp{h}=\umpcodp{g}
\end{array}
\end{equation*}
\end{definition}

The UMP opposite or dual mapping, $\umpclassp{op}\lessdot\umpclass$,
is an involutive unary mapping, hence dual, that transposes domain and
codomain for every arrow in any category, $\parsecat{C}\in\functcatcat$,
essentially reversing the direction of arrows.
Every category, $\parsecat{C}\in\functcatcat$, is paired with a dual associate,
$\parsecat{C}^{op}\in\functcatcat$.
The pair, $(\parsecat{C},\,\parsecat{C}^{op})$, are associated
by dual UMP mapping, $\umpclassp{op}$,
a distinct subclass of the functor class $\umpclass$.

\begin{definition}{Dual, Universal Mapping Property, $\umpclassp{op}$}
  \label{def:opposite},
  is a subclass of the large functor class, $\umpclass$.
  $\umpclassp{op}$ transforms any category,
  $\parsecat{C}\in\functcatcat$
  to a dual category, $\parsecat{C}^{op}$,
  denote $\umpclasspc{op}{C}=\parsecat{C}^{op}$:
  \label{def:cdual}\\[3pt]
  \begin{itemize}
  \item\textbf{(Object Dual)}
    $\ccobj{C}^{op}=\{\obk{o}^{op}\mid\obk{o}\in\ccobj{C}\}$
  \item\textbf{(Arrow Dual)}
    \begin{equation*}
      \begin{array}{rr}
        \catarr{C}^{op}=\{\arr{r}^{op}\mid &
                  \arrdom{r}^{op}=\arrcod{r}\quad \\[3pt]
          \quad & \text{and}\;\arrcod{r}^{op}=\arrdom{r}\quad \\[3pt]
          \quad & \forall\,\arr{r}\in\catarr{C}\;\,\} \\[3pt]
      \end{array}
    \end{equation*}
  \item\textbf{(Identity)} $\parsecat{C}=(\parsecat{C}^{op})^{op}$
  \end{itemize}
\end{definition}

A shorthand notation, $*$, for the dual of a category, $\parsecat{C}$,
is $\parsecat{C}^*=\parsecat{C}^{op}$.

\subsubsection{Hom Category}

In topology the segregation of category arrows by common domain and codomain
properties is a useful construct. 
As such a homomorphic (Hom) UMP, $\umpclassp{\rightarrow}\lessdot\umpclass$, 
transofrms a category, $\parsecat{C}\in\umpdomp{\rightarrow}$,
into a category, $\carr{C}\in\umpcodp{\rightarrow}$, based on structural
subcollections of arrows sharing common domain and codomain properties.

The structure of Hom categories relative to the structure of $2-categories$
already developed requires an incremental definition.
An essential UMP order projection
transfrom from $n^{th}$ order arrows and to lower order ${n-1}^{st}$ order
objects establishes an essential development tool.
Such a UMP projection tool generalizes the domain, $\oper{dom}$, and
codomain, $\oper{cod}$, operators which project first order arrows
to $0^{th}$ order domain and codomain objects, respectively.
In first order a Hom Index is collection of arrow domain and codomain
object pairs mapped by a projection operator, $\nprojection{1}$.
In particular the $\oper{dom}$ and $\oper{cod}$ operators
are equivalently expressed:

\begin{equation*}
  \oper{dom}=\nprojdown{1}{dom}\quad\text{and}\quad\oper{cod}=\nprojdown{1}{cod}
\end{equation*}

likewise for any arrow, $\arr{f}\in\pazocal{C}$,

\begin{equation*}
\begin{array}{rll}
  \nprojection{1}(\arr{f})&=&
  \pair{\nprojdown{1}{dom}(\arr{f})}{\nprojdown{1}{cod}(\arr{f})} \\[3pt]
  &=&\pair{\arrdom{f}}{\arrcod{f}}
\end{array}
\end{equation*}

Combining the above extends the order projection as a mapping of a category
arrow collection to a collection of domain/codomain object pairs,
the definition of Hom Index

\begin{definition}{Hom Index}\label{def:arrowindex}
\begin{equation*}
  \wrpobj{\ccpair{C}}=\{\nprojection{1}(\arr{f})\mid\arr{f}\in\catarr{C}\}
\end{equation*}
\end{definition}

Extending further establishes the homomorphic (Hom) UMP,
$\umpclassp{\rightarrow}\lessdot\umpclass$, 
transforms a category, $\parsecat{C}\in\umpdomp{\rightarrow}$,
into a category, $\carr{C}\in\umpcodp{\rightarrow}$, based on structural
subcollections of arrows sharing common domain and codomain properties.

\begin{definition}{Homomorphic (Hom) UMP,
    $\umpclassp{\rightarrow}\lessdot\umpclass$,}\label{def:arrowcatclass} \\
\begin{equation*}
\forall\,\parsecat{C}\in\umpdomp{\rightarrow}\quad
\text{denote}\quad\carr{C}=\umpclassp{\rightarrow}(\parsecat{C})\in
\umpcodp{\rightarrow}
\end{equation*}
\end{definition}

Each object pair, $\cpair{a}{b}\in\wrpobj{\ccpair{C}}$, segregates a
homomorphic (Hom) collection of arrows, $\carrobj{C}\cpair{a}{b}$,
sharing a common domain, $\obk{a}$, and codomain, $\obk{b}$.
The complete collection of Hom objects, $\carrobj{C}$,
relative to a category, $\parsecat{C}$, is the collection:

\begin{definition}{Hom Category,
  Hom Object Collection, $\carrobj{C}$}\label{def:homobject},
  for a category, $\parsecat{C}\in\functcatcat$, is a collection of Hom objects
  $\carrobj{C}\cpair{a}{b}$, each indexed by $\cpair{a}{b}\in\ccpair{C}$:
\begin{equation*}
  \begin{array}{rl}
    \carrobj{C}\cpair{a}{b}=\{\arr{f}\mid&
                          \arr{f}\in\catarr{C}\quad\text{and} \\[3pt]
    \quad&\cpair{a}{b}=\nprojection{1}\,\arr{f}\}
  \end{array}
\end{equation*}
\end{definition}

Higher order construction of the Hom Category extends more directly with
the construction of the Hom Index category, $\ccpair{C}$. In particular,
the arrow collection, $\ccarr{C}$, provides a direct source of arrow
pairs to map object pairs from, $\wrp{\ccpair{C}}$.
The simplest construct follows from constructs with identity arrows.
Each pair, $\cpair{a}{b}\in\wrpobj{\ccpair{C}}$, qualifies an identity arrow,
$\arrid{\cpair{a}{b}}$, to identify objects of the collection, $\carrobj{C}$,

\begin{equation*}
\begin{gathered}
  \forall\;\cpair{a}{b}\in\wrpobj{\ccpair{C}}\quad
  \arrid{\cpair{a}{b}}=\fpair{\arrid{a}}{\arrid{b}}\in\wrparr{\ccpair{C}}\\[3pt]
   \text{where},\quad\obk{a},\,\obk{b}\in\ccobj{C}\quad\Rightarrow\quad
   \arrid{a},\,\arrid{b}\in\ccarr{C}
\end{gathered}
\end{equation*}

Additional arrows in the collection, $\wrparr{\ccpair{C}}$, construct
as follows:

\begin{equation*}
\begin{array}{rll}
  \farr{f}{g}=\apair{f}{g}&\in&\wrparr{\ccpair{C}},\,\text{if}\,\,
  \arr{f},\,\arr{g}\in\ccarr{C}, \\[3pt]
\text{where}\quad&& \\[3pt]
  \farrdom{f}{g}&=&\cpair{\arrdom{f}}{\arrdom{g}}\in\wrpobj{\ccpair{C}},\\[3pt]
  \farrcod{f}{g}&=&\cpair{\arrcod{f}}{\arrcod{g}}\in\wrpobj{\ccpair{C}},\\[3pt]
  \arr{f}=\arrpifst{f}{g},&&\arr{g}=\arrpisnd{f}{g}
\end{array}
\end{equation*}

Each arrow, $\farr{f}{g}$, of the collection, $\wrparr{\ccpair{C}}$,
maps domain/codomain object pairs of the collection, $\wrpobj{\ccpair{C}}$:

\begin{equation*}
\begin{array}{rll}
  \cpair{\arrcod{f}}{\arrcod{g}}&=& \\[3pt]
  \farr{f}{g}&\circ&\cpair{\arrdom{f}}{\arrdom{g}}
\end{array}
\end{equation*}

Projection options other characteristics such as selecting first and
second members of the function pair, $\apair{f}{g}$:

\begin{equation}\label{eq:firstsecondindex}
  \begin{array}{rll}
  \arr{f}&=&\arrpifst{f}{g} \\[3pt]
  \arr{g}&=&\arrpisnd{f}{g}
  \end{array}
\end{equation}

The identities, $\arrid{\cpair{a}{b}}$, are indexed by the collection,
$\wrpobj{\ccpair{C}}$, each instantiates a unique Hom object collection,
$\carrobj{C}$, from the category, $\pazocal{C}$:

\begin{equation*}
  \carrobj{C}\cpair{a}{b}=\arrid{\cpair{a}{b}}(\pazocal{C})
  \Longleftrightarrow\cpair{a}{b}
  \in\ccpair{C}
\end{equation*}
\begin{equation*}
  \carrobj{C}=\{\arrid{\cpair{a}{b}}(\pazocal{C})\mid
  \arrid{\cpair{a}{b}}\in\wrparr{\ccpair{C}}\}
\end{equation*}

Equivalently, the arrow collection, $\wrparr{\ccpair{C}}$, acts on the
Hom object collection, $\carrobj{C}$:

\begin{equation*}
\begin{array}{rll}
  \carrobj{C}\cpair{\arrcod{f}}{\arrcod{g}}&=& \\[3pt]
  \farr{f}{g}&\circ&\carrobj{C}\cpair{\arrdom{f}}{\arrdom{g}}
\end{array}
\end{equation*}

The arrow collection, $\carrarr{C}$, of the category, $\carr{C}$, 
minimally consists of the aformentioned identity arrows,
\begin{equation*}
  \arrid{\cpair{a}{b}}=\farrid{a}{b}\;
  \forall\,\cpair{a}{b}\in\ccpair{C}
\end{equation*}

\begin{definition}{Hom Category,
  Arrow Collection, $\carrarr{C}$,}\label{def:arrowcategory}
consists of arrow pairs with domain and codomain in the
object collection, $\carrobj{C}$:
\begin{equation*}
\begin{array}{rlll}
  \carrarr{C}=\{&\farr{f}{g}&\mid& \\[3pt]
  &&&\apair{f}{g}=\farrid{a}{b}, \\[3pt]
  &&&\quad\cpair{a}{b}\in\wrpobj{\ccpair{C}} \\[3pt]  
  &\text{or}&&\farrpidom{f}{g},\, \\[3pt]
  &&&\quad\farrpicod{f}{g}\in\wrpobj{\ccpair{C}} \\[3pt]
  &\text{and}&&\arr{f},\,\arr{g}\in\catarr{C} \}
\end{array}
\end{equation*}
\begin{equation*}
\forall\quad\arr{r}\in\carrarr{C}\quad
       \arrpidom{r},\,\arrpicod{r}\in\carrobj{C}
\end{equation*}
\end{definition}

Each object, $\carrobj{C}\cpair{a}{b}$, is a collection of arrows
uniquely sharing the domain $\obk{a}$ and codomain $\obk{b}$.
By definition of arrows, an arrow,
$\arr{f}\in\carrobj{C}\cpair{a}{b}$, cannot be a member,
$\arr{f}\notin\carrobj{C}\cpair{a^{\prime}}{b^{\prime}}$,
for unmatched domain and codomain pairs, $a\neq a^{\prime}$ or
$b\neq b^{\prime}$. Hence each object,
$\carrobj{C}\cpair{a}{b}\in\carrobj{C}$, is an equivalence
class of arrows sharing the same domain and codomain property,
$\cpair{a}{b}\in\ccpair{C}$.
Each object of $\carrobj{C}$ is a distinct arrow collection which
partitions the arrow collection, $\ccarr{C}$,
this stands for any category $\parsecat{C}$.
Equivalence classes and partitions are
elaborated in the relation section.

Applying the projection operator, $\nprojection{1}$, again
ont the category $\ccpair{C}$ constructs an object collection
consisting of pairs of pairs of objects from the category, $\pazocal{C}$:

\begin{equation}\label{eq:firstsquareindex}
\ccpairn{2}{C}=\nprojection{1}\,\ccpair{C}
\end{equation}

An object of the collection, $\wrpobj{\ccpairn{2}{C}}$, is nominally a
a second order Hom index:

\begin{definition}{Second Order Hom Index}\label{def:arrowarrowindex}
\begin{equation}\label{eq:arrowarrowindex}
  \begin{array}{rl}
    \wrpobj{\ccpairn{2}{C}}=\{&
              \pair{\farrpidom{f}{g}}{\farrpicod{f}{g}}\mid \\[3pt]
  \quad & \;\,\farrpidom{f}{g},\farrpicod{f}{g}\in\ccpair{C} \\[3pt]
    \quad & \qquad\qquad\text{and}\quad
            \arr{f},\,\arr{g}\in\catarr{C} \}
  \end{array}
\end{equation}
\end{definition}

The objects of $\ccpairn{2}{C}$ consist of nested pairs
of objects from the category, $\parsecat{C}$, restricted
by the existence of arrows with corresponding domain and
codomain pairs. Commutation of domain, \oper{dom}, and
codomain, \oper{cod}, arrows with the pair operation
clarify equation, \ref{eq:arrowarrowindex}.

For any category, $\parsecat{C}$, the nested pair collection,
$\ccpairn{2}{C}$, maps domain to codomain homomorphic objects of the
collection, $\carrobj{C}$. This process clearly defines a partition of
the arrow collection, $\carrarr{C}$ based on common domain and codomain
arrows that transform partitions indexed by, $\ccpair{C}$.
The entirety of these mappings establish the arrow collection,
$\umpclasspc{\rightarrow}{C}$.

The arrow collection, $\carrarr{C}$, of a particular category, $\parsecat{C}$,
consists of pairs of arrows sharing the
same domain and codomain designations, indexed by the
collection, $\ccpairn{2}{C}$.
Figure, \ref{fig:arrowcategory}, illustrates the the arrows
in the collection, $\carrarr{C}$, map a domain arrow to a codomain
arrow, an action consitituting a second order arrow.
The Recursive application of the Hom UMP constructs
higher order arrows with object indices, $\ccpairn{n}{C}$, conforming to
deeper arrow structure. Ad infinitum,
recursive categories, $\carrn{C}{n}$, $\carr{C}=\carrn{C}{1}$,
$\parsecat{C}=\carrn{C}{0}$, are defined by matching
arrow domain and codomain in nested pair structures
of any category $\parsecat{C}\in\largecatobj$. Categories
with higher order arrow collections are designated as,
$n-category$. Prior sections focused on the $1-category$,
with first order arrows. A $0-category$ denotes a collection.
Recursive arrow mapping construct higher order arrow collections
that contribute to higher order categories. Trivially,
any $n^{th}$ order arrow in an $n-category$ has an $n+1^{st}$ order
identity arrow. Hence any categoriy trivially extends to higher orders. 

\begin{figure}\label{fig:arrowcategory}
     \begin{tikzpicture}[
            > = stealth, % arrow head style
            shorten > = 1pt, % don't touch arrow head to node
            auto,
            node distance = 3cm, % distance between nodes
            semithick % line style
        ]
        \draw [thin,gray,dashed] (1.5,0) ellipse (1.8cm and .6cm)
                    node[text=gray] at (1.5,.2) {$\arr{h}$};
        \draw [thin,gray,dashed] (1.5,-3) ellipse (1.8cm and .6cm)
                    node[text=gray] at (1.5,-3.2) {$\arr{r}$};
        \node[] (A) {$a$};
        \node[] (B) [right of=A] {$b$};
        \node[] (D) [below of=A] {$a^{\prime}$};
        \node[] (C) [below of=B] {$b^{\prime}$};
        
        \path[->] (A) edge node[below] {$\carrobj{C}\cpair{a}{b}$} (B);
        \path[->] (A) edge node[left] {$\arr{f}$} (D);
        \path[->] (B) edge node {$\arr{g}$} (C);
        \path[->] (D) edge node[above]
                      {$\carrobj{C}\cpair{a^{\prime}}{b^{\prime}}$} (C);
        \draw[dashed,->] (1.5, -.8) -- (1.5, -2.2)
                      node[midway,right] {$\oarr{2}{\mu}$};
    \end{tikzpicture}
      \caption {$\pazocal{C}_{\rightarrow}$, Hom Category 
        \begin{equation*}
        \begin{array}{ll}
          \quad\bullet\quad&\ofarr{2}{f}{g}=\oarr{2}{\mu}
        \end{array}
        \end{equation*}
      \begin{equation*}
      \begin{array}{lrlllrll}
          \quad\bullet\quad&\cpair{a}{b}&=&\oarrpiop{2}{dom}{\oarr{2}{\mu}},
          &&
          \cpair{a^{\prime}}{b^{\prime}}&=&\oarrpiop{2}{cod}{\oarr{2}{\mu}} \\
          \quad\bullet\quad&\arr{h}&=&\oarrpiop{1}{dom}{\oarr{2}{\mu}},
          &&
          \arr{r}&=&\oarrpiop{1}{cod}{\oarr{2}{\mu}} \\
          \quad\bullet\quad&\arr{f}&=&\oarrpiop{1}{fst}{\oarr{2}{\mu}},
          &&
          \arr{g}&=&\oarrpiop{1}{snd}{\oarr{2}{\mu}}
        \end{array}
        \end{equation*}
        \begin{equation*}
        \begin{array}{ll}
          \quad\bullet\quad&\wrapobj{\pazocal{C}^{\rightarrow}}\cpair{a}{b}
            \xrightarrow{\;\oarr{2}{\mu}\;}
            \wrapobj{\pazocal{C}^{\rightarrow}}
            \cpair{a^{\prime}}{b^{\prime}}
        \end{array}
        \end{equation*}
        }\label{fig:arrowcategory}
\end{figure}

The nested structures that evolve from recursive arrow mapping,
$\umpclassp{\rightarrow}$, directly facilitate the criteria for a subcategory:

\begin{definition}{Subcategory}\label{def:subcategory},
  $\parsecat{D}$, of a category, $\parsecat{C}$, denote
  $\csub{\parsecat{D}}{\parsecat{C}}$,
  has the following properties:
  \begin{itemize}
    \item\textbf{(Subcollection)} $\catobj{D}\lessdot\catobj{C}$ 
    \item\textbf{(Arrow)}
      $\carrobj{D}\cpair{a}{b}\lessdot\carrobj{C}\cpair{a}{b}$ \\[3pt]
      for all $\cpair{a}{b}\in\ccpair{D}$
  \end{itemize}  
\end{definition}

Subcategory is a descriptive relation conveniently describing
the relevance of property structure between various pairs of large
categories. By examination the functor category, $\functcat$, is a
subcategory of the large category, $\largecat$:

\begin{equation*}
  \csub{\functcat}{\largecat}
\end{equation*}

Likewise UMP functor categories are subcategories of the functor category, $\functcat$: 

\begin{equation*}
  \csub{\functcatp{B}}{\functcat}\quad\forall\parsecat{B}\in\mathcal{B}
\end{equation*}


Subcategory relates a category pair, $\cpr{D}{C}$, characterized by
wide and full properties relative to object and local arrow subcollection
properties, respectively. Subcategory is a monomorphic functor mapping
the subcategory to the category of inclusion.

\begin{definition}{Subcategory Properties}\label{def:subcategoryproperties},
  $\parsecat{D}$, of a category, $\parsecat{C}$,
  denote $\csub{\parsecat{D}}{\parsecat{C}}$,
  may have the following properties:
  \begin{itemize}
    \item\textbf{(Wide)} $\catobj{D}=\catobj{C}$ 
    \item\textbf{(Full)}
      $\carrobj{D}\cpair{a}{b}=\carrobj{C}\cpair{a}{b}$ \\[3pt]
      for all $\cpair{a}{b}\in\ccpair{D}$
  \end{itemize}
\end{definition}

An $n-category$ extends to include a collection
of second order arrows that transform arrows, a $2-category$.
The arrow, $\apair{f}{g}$, supports the functionality of
second order arrow used with a composition operation.

\begin{equation}\label{eq:arrowarrowpair}
  \begin{array}{rll}
    \arrdom{h}=\arrdom{f}&&\arrcod{h}=\arrdom{g} \\[3pt]
    \arrdom{r}=\arrcod{f}&&\arrcod{r}=\arrcod{g} \\[3pt]
    \arr{r}\circ\arr{f}&=&\arr{g}\circ\arr{h}
  \end{array}
\end{equation}

A pair, $\langle,\rangle$, of arrows applied to mapping objects
is a elementary introduction. Constructing second
a second order arrow, $\oarr{2}{\mu}$, from a pair of arrows
requires greater development.
Given a second order arrow, $\oarr{2}{\mu}$, 
mapping a domain arrow, $\arr{h}$ to a codomain arrow, $\arr{r}$
with a pair of arrows, $\ofarr{2}{f}{g}$ offers a useful construct:

\begin{equation}\label{eq:secondorderarrow}
  \begin{array}{rll}
    \oarr{2}{\mu}&=&\ofarr{2}{f}{g} \\[3pt]
    \arr{h}=\arrpiop{dom}{\oarr{2}{\mu}}&&
    \arr{r}=\arrpiop{cod}{\oarr{2}{\mu}} \\[3pt]
    \arr{f}=\arrpiop{fst}{\oarr{2}{\mu}}&&
    \arr{g}=\arrpiop{snd}{\oarr{2}{\mu}}
  \end{array}
\end{equation}

As before the matching domain and codomain of the arrows
are associated with a twist or dual applied to the first
pair component, $\arr{f}$:

\begin{equation}\label{eq:secondorderarrow}
  \begin{array}{rll}
    \arrdom{h}=\arrcod{f^*}&&\arrcod{h}=\arrdom{g} \\[3pt]
    \arrdom{r}=\arrdom{f^*}&&\arrcod{r}=\arrcod{g} \\[3pt]
    \arr{r}&=&\arr{g}\circ\arr{h}\circ\arr{f^*}
  \end{array}
\end{equation}

Additional notation introduces the new arrow pair representation
for second order arrows, $\ffpair{.}{.}$, and evaluation of the pair
relative to a domain arrow, $\epair{.}{.}$:

\begin{equation}\label{eq:secondorderarrow}
  \begin{array}{rll}
    \ofarr{2}{f}{g}&=&\oarr{2}{\mu} \\[3pt]
    \arr{r}=\ofarr{2}{f}{g}(\arr{h})&=&\arr{g}\circ\arr{h}\circ\arr{f^*} \\[3pt]
    \arr{r}=\ofarr{2}{f}{g}(\arr{h})&=&
            \efarr{1}{f\circ h^*}{g} \\[3pt]
           &=&\efarr{1}{f}{g\circ h} \\[3pt]
    \efarr{1}{f\circ h^*}{g}&=&(\arr{g})\circ(\arr{f}\circ\arr{h^*})^* \\[3pt]
    \efarr{1}{f}{g\circ h}&=&(\arr{g}\circ\arr{h})\circ(\arr{f})^*  \\[3pt]
               &=&\arr{g}\circ\arr{h}\circ\arr{f^*} \\[3pt]
\text{where}\qquad&&\\[3pt]
    &&\arr{h},\,\arr{r},\,\arr{f},\,\arr{g}\in\ccarr{C}
  \end{array}
\end{equation}

Recursively an, $n-category$, is derived from an $(n-1)-category$.
Likewise, the functor idiom extends to the existence of higher order
transformation from a domain functor to a codomain functor.
Natural transformation is the designation of a second order functor that
maps a domain functor to a codomain functor.

\subsection{Natural Transformation: \\
  $\hspace{24pt}$Second Order Functor}

The meta concept of a functor as a category lends to the concept
of a higher order functor that maps a domain functor to a codomain
functor. Natural transform designates the higher order functor of
interest. A natural transform embeds in the context of a higher order category.
A large natural category, $\largenat$, contains the collection of
all natural transforms:

\begin{definition}{Large Natural Category}\label{def:naturalcollection},
  Large Natural Transform Collection, consista of all 2-order functors
  with a functor domain and codomain 
\begin{equation*}
\begin{array}{llrll}
  \largenatnat=\{&\nfunct{\Theta}\mid&
  \funct{F}&=&\nfunctdom{\Theta}, \\[3pt]
  &&\funct{G}&=&\nfunctcod{\Theta}\quad \\[3pt]
  &\,\text{and}&\funct{F},\,\funct{G}&\in&\functcatfunct\,\}
\end{array}
\end{equation*}
\end{definition}

\begin{definition}{Large Natural Category}\label{def:naturalcollection},
  Functor Collection,
\begin{equation*}
\begin{array}{llrll}
  \largenatfunct=\{&\funct{F}\mid&
  \funct{F}&=&\nfunctdom{\Theta}, \\[3pt]
  &\text{or}&\funct{F}&=&\nfunctcod{\Theta}\quad \\[3pt]
  &\text{where}&\funct{F}&\in&\functcatfunct \\[3pt]
  &&\nfunct{\theta}&\in&\largenatnat\,\}
\end{array}
\end{equation*}
\end{definition}

\begin{definition}{Large Natural Category}\label{def:naturalcollection},\\[3pt]
  Object Collection,
\begin{equation*}
\begin{array}{llrll}
  \largenatcat=\{&\parsecat{O}\mid&
  \parsecat{O}&=&\functdom{F}, \\[3pt]
  &\text{or}&\parsecat{O}&=&\functcod{F}\quad \\[3pt]
  &\text{where}&\funct{F}&\in&\largenatfunct\,\}
\end{array}
\end{equation*}
\end{definition}

\begin{definition}{Large Natural Category}\label{def:naturalcategory},
\begin{equation*}
  \begin{array}{rl}
    \largenatcat\lessdot\functcatcat\quad\tezt{and}
    \quad&\largenatfunct\lessdot\functcatfunct
  \end{array}
\end{equation*}
\end{definition}

The large natural category, $\largenat$, overall consists of a collection of
all natural trnasforms, $\largenatnat$. The collection, $\largenatnat$,
selectively restricts membership of the functor collection, $\largenatfunct$,
and the object collection, $\largenatcat$, from the larger and less restrictive
property membership of the large category, $\functcat$.
A greater part of analysis is restricted to natural transformation on
homomorphic object collections, $\natfunct{C}{D}\lessdot\largenatfunct$,
consisting of functors with a domain/codomain category pair, $\cpr{C}{D}$,
where $\parsecat{C},\,\parsecat{D}\in\largenatcat$.
A collection of natural transformations, $\natnat{C}{D}\lessdot\largenatnat$,
extends as an endomorphic collection over the homomorphic object,
$\natfunct{C}{D}\lessdot\largenatfunct$.
Each natural transform, $\nfunct{\theta}\in\natnat{C}{D}$, supports a
domain, $\nfunctdom{\theta}$, and codomain functor, $\nfunctdom{\theta}$, in,
$\natfunct{C}{D}$.
$\natnat{C}{D}$, designates the collection of natural transformation with
domain/codomain in the functor collection, $\natfunct{C}{D}$.
Development of the definition for natural transforms parallels the development
of second order arrows from definition, \ref{def:arrowcategory}.

\begin{definition}{Natural Transform, Functor Objects}
  \label{def:naturalfunctor},
\begin{equation*}
  \begin{array}{rl}
    \natfunct{C}{D}=\{\funct{F}\mid&
                          \funct{F}=\nfunctdom{\theta}\quad\text{or} \\[3pt]
    &\funct{F}=\nfunctcod{\theta},\\[3pt]
    \text{where}&\nfunct{\theta}\in\natnat{C}{D}\,\}
  \end{array}
\end{equation*}
\end{definition}

The collection of natural transforms, $\natnat{C}{D}$,
consists of second order functors that map a domain functor to a
codomain functor within the object collection, $\natfunct{C}{D}$

\begin{definition}{Natural Transform}\label{def:naturaltransform},
  Natural Transform Collection,
\begin{equation*}
\begin{array}{llrll}
  \natnat{C}{D}=\{&\nfunct{\Theta}\mid&
  \funct{F}&=&\nfunctdom{\Theta}, \\[3pt]
  &&\funct{G}&=&\nfunctcod{\Theta}\quad \\[3pt]
  &\,\text{and}&\funct{F},\,\funct{G}&\in&\natfunct{C}{D}\,\}
\end{array}
\end{equation*}
\end{definition}

A natural transform consists of a collection of second order arrows,
$\oarr{2}{\theta}\in\owrparr{,2}{\nfunct{\Theta}}$

\begin{theorem}[Pivot Projection]\label{thm:pivotprojection},
  reduces a second order arrow, $\oarr{2}{\mu}$, with preconditions, to an
  equivalent first order arrow, $\arr{\mu}$.
  Recall the representation of a second order arrow by first order
  arrows, figure \ref{fig:arrowcategory}, as posited by the second order
  Hom index, def. \ref{def:arrowarrowindex}.
  The pivot projection acts on a second order arrow,
  $\oarr{2}{\mu}\in\cfnat{f}{g}_{\obk{2}}$, mapping
  a domain arrow, $\arr{f}$, to a codomain arrow, $\arr{g}$,
  where, $\arrdom{f}=\arrdom{g}$, as such the arrow, $\oarr{2}{\mu}$,
  membership to a second order Hom object,
  $\oarr{2}{\mu}\in\cfnat{f}{g}_{\obk{2}}$, alternately represented
  with pair of arrows, 
\begin{equation}
\begin{array}{rll}
\oarr{2}{\mu}&=&\ofarr{2}{\arrid{a}}{\arr{\mu}}, \\[3pt]
\arrid{a}&=&\oarrpiop{1}{fst}{\oarr{2}{\mu}}, \\[3pt]
\arr{\mu}&=&\oarrpiop{1}{snd}{\oarr{2}{\mu}}, \\[3pt]
\text{where}\quad&& \\[3pt]
\obk{a}&=&\arrdom{f}=\arrdom{g} \\[3pt]
\arrdom{\mu}=\arrcod{f}&,&\arrcod{\mu}=\arrcod{g}
\end{array}
\end{equation}
  Equivalently, a second order arrow mapping $\oarr{2}{\mu}$, projects to a
  composition with a first order arrow:
\begin{equation}
\begin{gathered}
\mapaob{\arr{f}}{\obk{2},\mu}{\arr{g}} \\
\arr{g}=\arr{g}\circ\arrid{a}=\arr{\mu}\circ\arr{f}
\end{gathered}
\end{equation}
\end{theorem}

\begin{corollary}{Copivot Projection}\label{cor:copivotprojection},
  reduces a second order arrow, $\oarr{2}{\mu}\in\cfnat{f}{g}_{\obk{2}}$, to an
  equivalent first order arrow, $\arr{\mu}=\nprojfst{1}{\oarr{2}{\mu}}$,
  In detail, copivot projection acts on a second order arrow,
  $\oarr{2}{\mu}\in\cfnat{f}{g}_{\obk{2}}$, mapping
  a domain arrow, $\arr{f}$, to a codomain arrow, $\arr{g}$,
  where, $\arrdom{f}=\arrdom{g}$, as such the natural arrow, $\oarr{2}{\mu}$,
  membership to a second order Hom object,
  $\oarr{2}{\mu}\in\cfnat{f}{g}_{\obk{2}}$, alternately represented
  with pair of arrows, 
\begin{equation}
\begin{array}{rll}
\oarr{2}{\mu}&=&\ofarr{2}{\arr{\mu}}{\arrid{a}}, \\[3pt]
\arr{\mu}&=&\oarrpiop{1}{fst}{\oarr{2}{\mu}}, \\[3pt]
\arrid{a}&=&\oarrpiop{1}{snd}{\oarr{2}{\mu}}, \\[3pt]
\text{where}\quad&& \\[3pt]
\obk{a}&=&\arrcod{f}=\arrcod{g} \\[3pt]
\arrdom{\mu}=\arrdom{f}&,&\arrcod{\mu}=\arrdom{g}
\end{array}
\end{equation}
  Equivalently, a second order arrow mapping $\oarr{2}{\mu}$, projects to a
  composition with a first order arrow:
\begin{equation}
\mapaob{\arr{f}}{\obk{2},\mu}{\arr{g}} \\
\end{equation}
reduces to,
\begin{equation}
\arr{f}\circ\arr{\mu}=\arrid{a}\circ\arr{g}=\arr{g}
\end{equation}
\end{corollary}

The pivot and copivot projection employs a pointwise argument. Extending
theorem \label{thm:pivotprojection} and corollary \label{cor:copivotprojection},
to the behavior of natural transforms requires uniformity over collections,
a characteristic that requires determinacy, indexing and limits,
concepts specific to sets.

The natural transform collection, $\natnat{C}{D}$,
supports composition and contains natural identities for functors
in the collection, $\natfunct{C}{D}$,
completing validation for a the natural category, $\cnat{C}{D}$.

\begin{definition}{Natural Category}\label{def:naturalcategory},
  A natural category, designated as $\cnat{C}{D}$, is defined
  over a homomorphic object, $\natfunct{C}{D}$, a collection of functors
  with a common domain/codomain pair of categories, $\cpr{C}{D}$.
  The collection of natural tranasformations, $\natnat{C}{D}$, over
  the domain/codomain pairs of functors from $\natfunct{C}{D}$
  completes qualification as a category with the following
  identity natural transform of functors:

\begin{equation*}
  \begin{array}{rl}
    \forall\,\funct{F}&\in\natfunct{C}{D}
                        \quad\oper{id}_{\obk{F}}\in\natnat{C}{D} \\[5pt]
   \text{where}\qquad& \\[5pt]
    \funct{F}&=\oper{id}_{\obk{F}}(\funct{F})
  \end{array}
\end{equation*}
\end{definition}

Thus far a category of natural transforms are detailed over functor
collections with a common domain and codomain category. More generally
a natural transform category defines mappings over distinct domain and
codomain functor categories.

within the object collection, $\natfunct{\cpr{C}{D}}{\cpr{X}{Y}}$

\begin{definition}{Natural Transform, Functor Objects}
  \label{def:naturalfunctor}, \\

% \begin{align*}
    $\quad\natfunct{\cpr{C}{D}}{\cpr{X}{Y}}=$
%\end{align*}
\begin{equation*}
  \begin{array}{rll}
    \{\funct{F}&\mid&
    \funct{F}=\nfunctdom{\theta}\in\functcatfunct\cpr{C}{D} \\[3pt]
    \quad\text{or}&&
    \funct{F}=\nfunctcod{\theta}\in\functcatfunct\cpr{X}{Y}, \\[3pt]
    \text{where}&&\nfunct{\theta}\in\natnat{\cpr{C}{D}}{\cpr{X}{Y}}\,\}
  \end{array}
\end{equation*}
\end{definition}

\begin{definition}{Natural Transform}\label{def:generalnaturaltransform},
  Natural Transform Collection, with distinct domain and codomain
  functor collections:
\begin{equation*}
\begin{array}{rl}
  \natnat{\cpr{C}{D}}{\cpr{X}{Y}}&=\{\nfunct{\Theta}\mid \\[3pt]
  \funct{F}=&\nfunctdom{\Theta}, \\[3pt]
  \funct{G}=&\nfunctcod{\Theta}\quad \\[3pt]
  \text{and}\quad
  \funct{F},\,\funct{G}\in&\natfunct{\cpr{C}{D}}{\cpr{X}{Y}}\,\}
\end{array}
\end{equation*}
Inferential to the definition:
\begin{equation*}
\begin{array}{rl}
  \oper{dom}&\natfunct{\cpr{C}{D}}{\cpr{X}{Y}}\lessdot
  \functcatfunct\cpr{C}{D} \\[3pt]
  \text{and}\quad\oper{cod}&\natfunct{\cpr{C}{D}}{\cpr{X}{Y}}\lessdot
  \functcatfunct\cpr{X}{Y}
\end{array}
\end{equation*}

\end{definition}

The constituents of a natural category support the development of advanced
analytical tools. Adjunctive pairs designated as left and right categories,
functors and natural transforms provide an advanced analytical structure. Monads
and operads build on adjunction to develop other analytical structures.

\subsection{Adjunction}

Higher order functors such as natural transforms extend access to
complex category structure for analysis and construction.
The adjoint in particular employs bihomomorphic relationships between
category and functor pairs. The adjoint is based on a multi-order
relation between a pair of functors, denoted by an asymmetric
adjunction operator, $\dashv$. The first functor of the pair is
designated as the left adjoint and the second functor is designated
as the right adjoint. The category domain/codomain targets of the
adjunction are also discriminated as a left category and right category.
Adjunctive compositon denotes another pair of functors. Give the adjunctive
functor pair, $\adjfunct{L}{R}$, with adjunctive categories,
$\adjcat{C}{D}$, the adjunctive composition is denoted as, $\adjcom{L}{R}$.
The triviality of adjunctive composition indicates the relevance of
left and right adjunction.
Trivial adjunctive functors compose to the identity with limited analytical
or constructive aplication.
A non-trivial adjunctive functors pair distinguishes an adjunctive
natural transform pair, denoted as, $\adjnat{\eta}{\epsilon}$.
The adjoint natural transform pair act on the adjoint composition relative
to the identities of the adjoint pair of categories:

\begin{equation*}
  \mapaob{\functid{C}}{\eta}{\funct{\obk{R}\circ\obk{L}}}\;\dashv\;
  \mapaob{\funct{\obk{L}\circ\obk{R}}}{\epsilon}{\functid{D}}
\end{equation*}
where,
\begin{equation*}
\adjcat{C}{D},\quad\adjfunct{L}{R}\quad\text{and}\quad\adjnat{\eta}{\epsilon}
\end{equation*}

A significant adjunctive system supports
analysis and construction in disparate
adjuctive categories characterized by distinct behavior and characteristics.
Adjunctive functor composition principally applies to monad analysis.
Monad analysis proceeds with a two tier process 1)
a left adjoint expansion of the left category into a
more complex right category for analysis 2)
a right adjoint functor reduces the right category result back into
into a simpler left category construct. 

\begin{definition}{Adjunction},\label{def:adjointfunctor} \\[3pt]
  \begin{equation*}
  \adj{\adjtpl{C}{L}{\eta}}{\adjtpl{D}{R}{\epsilon}}
  \end{equation*}
  A complete description of an adjunction is specified by a
  left adjunct $3-tuple$,
  $\adjtpl{C}{L}{\eta}$, and a right adjunct $3-tuple$,
  $\adjtpl{D}{R}{\epsilon}$.
  An adjunct triple consists of a category
  first member, a functor second member and a natural transform third member.
  Denotes a pair of adjoint functors as, $\adjfunct{L}{R}$.
  Specifically, $\funct{L}$ is a left adjoint functor,
  and $\funct{R}$ is a right adjoint functor.
  Functors, $\funct{L}$ and $\funct{R}$, of the adjunction,
  are assumed members of the collection $\functcatfunct$.
  The adjunct functors, $\adjfunct{L}{R}$, relate a pair of
  adjunct categories, $\adjcat{C}{D}$, where
  $\parsecat{C}$ and $\parsecat{D}\in\functcatcat$; with
  $\parsecat{C}=\functdom{L}=\functcod{R}$ and
  $\parsecat{D}=\functcod{L}=\functdom{R}$.
  As such, the adjunct categories, $\adjcat{C}{D}$,
  have corresponding identity functors, $\functid{C}$ and
  $\functid{D}\in\functcatfunct$, respectively.
  In further detail, the adjunction, $\adjfunct{L}{R}$,
  has an adjunct composition, $\adjcom{L}{R}$.
  Adjunct compositions consists of a pair of endomorphisms
  over corresponding adjoint categories, $\adjcat{C}{D}$, respectively.
  Denote a trivial adjunct composition as,
  $\adj{\oper{id}_{\pazocal{C}}}{\oper{id}_{\pazocal{D}}}$.
  Nontrivial adjunct composition affects from a nontrivial
  adjunct natural transform pair, $\adjnat{\eta}{\epsilon}$,
  where $\nfunct{\eta}$ denotes the unit natural transform, and,
  $\nfunct{\epsilon}$, denotes the counit natural transform.
  The unit transform conforms to the map,
  $\mapaob{\functid{C}}{\eta}{\funct{\obk{R}\circ\obk{L}}}$.
  The counit transform conforms to the map,
  $\mapaob{\funct{\obk{L}\circ\obk{R}}}{\epsilon}{\functid{D}}$.
  The unit and counit satisfy the following
  adjunctive triange identities with a higher order
  composition operator, $.$\,:
  \begin{itemize}
  \item\textbf{(Left Triangle Identity)},
    $\oper{id}_{\obk{L}}&=&\epsilon\obk{L}.\obk{L}\eta$ \\[3pt]
    $\mapaob{\funct{L}}{\obk{L}\eta}
    {\mapaob{\funct{\obk{L}\circ\obk{R}\circ\obk{L}}}
      {\epsilon\obk{L}}{\funct{L}}}\quad$;
    where
\begin{equation*}
  \begin{array}{lrl}
      \mapaob{\funct{L}}{\obk{L}\eta}{\funct{\obk{L}\circ\obk{R}\circ\obk{L}}}
    &=&
    \funct{L}\circ\left(\mapaob{\functid{C}}{\eta}{\funct{\obk{R}\circ\obk{L}}}
           \right) \\[3pt]
    \text{and}&& \\[3pt]
    \mapaob{\funct{\obk{L}\circ\obk{R}\circ\obk{L}}}{\epsilon\obk{L}}{\funct{L}}
    &=&
      \left(\mapaob{\obk{L}\circ\obk{R}}{\epsilon}{\functid{D}}
           \right)\circ\funct{L}

\end{array}
\end{equation*}
  \item\textbf{(Right Triangle Identity)},
    $\oper{id}_{\obk{R}}&=&\obk{R}\epsilon.\eta\obk{R}$ \\[3pt]
    $\mapaob{\funct{R}}{\eta\obk{R}}{\mapaob{\funct{R\circ L\circ R}}{\obk{R}\epsilon}{\funct{R}}}\quad$; where
\begin{equation*}
  \begin{array}{lrl}
      \mapaob{\funct{R}}{\eta\obk{R}}{\funct{R\circ L\circ R}}
    &=&
      \left(\mapaob{\functid{C}}{\eta}{\funct{R\circ L}}
           \right)\circ\funct{R} \\[3pt]
    \text{and}&& \\[3pt]
      \mapaob{\funct{R\circ L\circ R}}{\obk{R}\epsilon}{\funct{R}}
    &=&
      \funct{R}\circ\left(\mapaob{\funct{L\circ R}}{\epsilon}{\functid{D}}
           \right)

\end{array}
\end{equation*}
\end{itemize}
\end{definition}

An adjunction, $\adj{\adjtpl{C}{L}{\eta}}{\adjtpl{D}{R}{\epsilon}}$,
directly supports the construction of a monad, $\montpl{M}{\eta}{\mu}$,
where, $\funct{M}=\funct{R\circ L}$, $\nfunct{\eta}=\nfunct{\eta}$ and
$\nfunct{\mu}=\nfunct{R\epsilon L}$. denote mapping:

\begin{equation*}
\begin{array}{l}
\mapaob{\funct{R\circ L\circ R\circ L}}{\obk{R}\epsilon\obk{L}}{\funct{R\circ L}}= \\[3pt]
\hspace{40pt}\funct{R}\circ\left(\mapaob{\funct{L\circ R}}{\epsilon}{\functid{D}}
           \right)\circ\funct{L}
\end{array}
\end{equation*}

Reducing further,

\begin{equation}
\mapaob{\funct{M\circ M}}{\mu}{\funct{M}}\label{eq:monadreduce}
\end{equation}
\begin{equation}
\mapaob{\functid{C}}{\eta}{\funct{M}}
\end{equation}
\begin{equation*}
\begin{array}{lll}
\funct{M}\circ\left(\mapaob{\functid{C}}{\eta}{\funct{M}}\right)&=&
         \mapaob{\funct{M}}{M\eta}{\funct{M\circ M}} \\[3pt]
\left(\mapaob{\functid{C}}{\eta}{\funct{M}}\right)\circ\funct{M}&=&
         \mapaob{\funct{M}}{\eta M}{\funct{M\circ M}}
\end{array}
\end{equation*}

This shows that the functor, $\funct{M}$, communtes with the
natural transform, $\nfunct{\eta}$.
Combining this result with eq. \ref{eq:monadreduce},
derives a monad endomorphism:

\begin{equation*}
\mapaob{\mapaob{\funct{M}}{M\eta}{\funct{M\circ M}}}{\mu}{\funct{M}}
\end{equation*}

Idempotent operator:

\begin{equation*}
\mapaob{\funct{M}}{\mu.\eta M}{\funct{M}}
\end{equation*}

\subsection{Universal Construction}

Construction of categories from existing categories proceeds
from reorganizing the structure of a category relative to
discrete properites to the combination of more than one category
as a new catgory. Collections of categories as ordered tuples
and unordered bags support useful idoms of construction.

\subsubsection{Slice and Coslice Category}

Elaborating on the construction of a new category from special properties
of an input category offers a furst pursuit. An initial topic concerns
subcategories of the Hom category denoted as slice and coslice categories.
An interesting corollary of slice and coslice leads to definitions
of initial and terminal objects respectively.

The slice map uses a common codomain object to filter objects
of the Hom category. 

\begin{definition}{Slice Category}\label{def:slicecategory},
  $\parsecat{C/c}$, transforms a category , $\parsecat{C}$,
  over an object, $\obk{c}\in\ccobj{C}$. Slice category objects and
  arrows are discriminated entirely from the arrow collection, $\ccarr{C}$.
  Each object in, $\catobj{C/c}$, is an arrow with $\obk{c}$ as a common
  codomain with Hom UMP by composition as follows:
  \begin{itemize}
  \item\textbf{(Object)} \\
    $\catobj{C/c}=\{\carrobj{C}\cpair{a}{c}\mid
    \cpair{a}{c}\in\ccpair{C}\}$ 
    \item\textbf{(Arrow)}
     \begin{equation*}\begin{array}{ll}
      \catarr{C/c}=&\\[3pt]
            \quad\{\arr{f}\mid&\pair{\arrdom{f}}{\obk{c}},\,
                        \pair{\arrcod{f}}{\obk{c}} \in\ccpair{C}\}
     \end{array}\end{equation*}
  \end{itemize}  
\end{definition}

A restricted Hom category, $\carr{C}\cpair{-}{c}$, alternately specifies a
a slice category, \ref{def:slicecategory},
where, $-$, indicates a variable for all domain objects of arrows in the
category, $\parsecat{C}$.
Variable notation is relevant in later sections.
The slice map transforms arrows of the domain category
to objects in a codomain category. The slice mapping
transforms any category $\parsecat{C}\in\functcatcat$
to a subclass of $\functcatcat$.
Slicing acts trivially on the empty category.

\begin{equation*}
\begin{array}{lllll}
  \quad\bullet & \catobj{C/c}&=&\{ \arr{f}\mid\ &
       \obk{c}=\arrcod{f},\,\arr{f}\in\ccarr{C}\} \\[3pt]
  \quad\bullet & \catarr{C/c}&=&\{ \arr{h}\mid  &
     \arr{g_1},\,\arr{g_2}\in\catobj{C/c},\,\arr{h}\in\ccarr{C} \\
    \quad & \; & \; & \quad & \text{where}\quad\arrdom{h}=\arrdom{g_1} \\[3pt]
    \quad & \; & \; & \quad & \text{and}\quad\arrcod{h}=\arrdom{g_2}, \\[3pt]
    \quad & \; & \; & \quad & \qquad\arr{g_1}=\arr{g_2}\circ\arr{h}\, \}
%    \quad & \; & \; & \quad &
%              \text{where}\quad\arr{g_1},\arr{g_2},\arr{h}\in\catarr{C} \}
\end{array}
\end{equation*}

Slice categories are a subclass of the collection $\functcatcat$.
An essential object of the category, $\parsecat{C/c}$, is the
identity arrow, $\arrid{c}$. Of more consequence is that the identity
arrow validates all objects of the collection, $\catobj{C/c}$, as valid arrows
of the same category, $\catobj{C/c}\lessdot\catarr{C/c}$ with
the final result that the domain of every arrow in the collecton,
$\catobj{C/c}$ is the identity arrow $\arrid{c}$.
    
\begin{equation*}
   \arr{f}=\arrid{c}\circ\arr{f}\;
   \text{where}\;\arrid{c},\,\arr{f}\in\catobj{C/c}\lessdot\catarr{C/c}
\end{equation*}

Interestingly, this propery establishes $\arrid{c}$ as the domain object
of the collection of arrows with the same collection of codomains,
$\catobj{C/c}$. Hence the slice of any category renders an special object
with the folowwing initial object property.

\begin{definition}{Initial Object, $\catN{0}$}\label{def:initial},
  of a category, $\parsecat{C}$, 
  is a common domain object of a collection of initial arrows.
  Each object, $\obk{o}\in\ccobj{C}$, is the codomain, $\obk{o}=\arrcod{f}$,
  of a unique initial arrow, $\arr{f}$, originating from the initial object,
  $\catN{0}=\arrcod{f}$.
  The collection of domain objects for the terminal arrows is
  equivalently the category object collection, $\ccobj{C}$.
  \begin{equation*}\begin{array}{l}
    \forall\;\obk{o}\in\ccobj{C}\quad\exists\quad \arr{f}\in\ccarr{C} \\[3pt]
    \text{such that}\quad\catN{0}=\arrdom{f}\;\text{and}\quad\obk{o}=\arrcod{f}
                   \end{array}
  \end{equation*}
\end{definition}

Prototypically, the initial category, denoted as $\catN{0}$,
consists of an empty object and respective arrow collection.

Initial arrows share a unique relation connecting an initial object
with a collection of codomain objects. 

The existential functor, $\exists_{\parsecat{C}}$, has an initial category,
$\catN{0}$,  domain with a codomain proposition, $\parsecat{C}$.
The existential proposition declares an entity, $\parsecat{C}$,
from nothing, $\catN{0}$.

Duality supports
another subcategory mapping of the Hom category to the coslice map.
The coslice map uses a common domain object to filter objects
of the Hom category.

\begin{definition}{Coslice Category}\label{def:coslicecategory},
  $\parsecat{c/C}$, has an object collection of arrows in, $\ccarr{C}$:
  $\parsecat{c/C}$, denotes an object, $\obk{c}$, over a
  category, $\parsecat{C}$. Coslice category objects and
  arrows are discriminated entirely from the arrow collection, $\ccarr{C}$.
  Each object in, $\catobj{c/C}$, is an arrow with $\obk{c}$ as a common
  domain with Hom UMP by composition as follows:
  \begin{itemize}
  \item\textbf{(Object)} \\
    $\catobj{c/C}=\{\carrobj{C}\cpair{c}{a}\mid
    \cpair{c}{a}\in\ccpair{C}\}$ 
    \item\textbf{(Arrow)}
  \begin{equation*}\begin{array}{ll}
      \catarr{c/C}=& \\[3pt]
          \quad\{\arr{f}\mid&\pair{\obk{c}}{\arrdom{f}},\,
          \pair{\obk{c}}{\arrcod{f}}\in\ccpair{C}\}
  \end{array}\end{equation*}
  \end{itemize}  
\end{definition}

The Hom UMP of a category, $\pazocal{C}$, with a variable codomain object,
$\carr{C}\cpair{c}{-}$, specifies the coslice category, $\parsecat{c/C}$,
\ref{def:coslicecategory}.

The slice and coslice categories share a duality relationship,
$\parsecat{c/C}=\parsecat{C^*/c^*}^*$:

\begin{equation*}
\begin{array}{lllll}
\quad\bullet & \catobj{c/C}&=&\{ \arr{f}\mid\ &
\obk{c}=\arrdom{f},\,\arr{f}\in\ccarr{C}\} \\[3pt]
\quad\bullet & \catarr{c/C}&=&\{ \arr{h}\mid  &
\arr{g_1},\,\arr{g_2}\in\catobj{c/C},\,\arr{h}\in\ccarr{C} \\[3pt]
    \quad & \; & \; & \quad & \text{where}\quad\arrdom{h}=\arrcod{g_1} \\[3pt]
    \quad & \; & \; & \quad & \text{and}\quad\arrcod{h}=\arrcod{g_2}, \\[3pt]
    \quad & \; & \; & \quad & \qquad\arr{h}\circ\arr{g_1}=\arr{g_2} \}
\end{array}
\end{equation*}

Coslice categories are a subclass of the collection $\functcatcat$.
As the dual of the slice category, the coslice category UMP
intrudes interesting dual properties.
Again an essential object of the category, $\parsecat{c/C}$, is the
identity arrow, $\arrid{c}$. Of more consequence is that the identity
arrow validates all objects of $\catobj{c/C}$ as valid arrows
of the same category, $\catobj{c/C}\lessdot\catarr{c/C}$ with
the final result that the codomain of every arrow in the collecton,
$\catobj{c/C}$ is the identity arrow $\arrid{c}$.
    
\begin{equation*}
   \arr{f}=\arr{f}\circ\arrid{c}\;
   \text{where}\;\arrid{c},\,\arr{f}\in\catobj{c/C}\lessdot\catarr{c/C}
\end{equation*}

Interestingly, this propery establishes $\arrid{c}$ as the codomain object
of the collection of arrows with the same collection of domains, the entirety
$\catarr{c/C}$. Hence the coslice of any category renders an special object
with the terminal object property. 

\begin{definition}{Terminal Object, $\catN{1}$}\label{def:terminal},
  of a category, $\parsecat{C}$, 
  is a common codomain object of a collection of terminal arrows.
  Each object, $\obk{o}\in\ccobj{C}$, is the domain, $\obk{o}=\arrdom{f}$,
  of a unique terminal arrow, $\arr{f}$,
  to the terminal object, $\catN{1}=\arrcod{f}$.
  The collection of domain objects for the terminal arrows is
  equivalently the category object collection, $\ccobj{C}$.
  \begin{equation*}\begin{array}{l}
    \forall\;\obk{o}\in\ccobj{C}\quad\exists\quad \arr{f}\in\ccarr{C} \\[3pt]
    \text{such that}\quad\catN{1}=\arrcod{f}\;\text{and}\quad\obk{o}=\arrdom{f}
                   \end{array}
  \end{equation*}
\end{definition}

Terminal arrows share a unique relation connecting a collection of domain
objects with a terminal object. 

The terminal object or category, $\catN{1}$, is a prototypical
singleton object or a singleton category, consisting of on object
with associated identity arrows of first and higher orders.
Generally, consider an object, $\obk{c}$, which uniquely defines the singleton
category, $\singletoncat{c}$.

\begin{definition}{Singleton Category, $\singletoncat{c}$}
  \label{def:singletoncategory},
\begin{equation*}
\begin{array}{llll}
\quad\bullet\quad&\wrpcobj{\singletoncat{c}}&=&\{\obk{c}\} \\[3pt]
\quad\bullet\quad&\wrpcarr{\singletoncat{c}}&=&\{\arrid{c}\}
\end{array}
\end{equation*}
\end{definition}

In category algebra, $\catN{1}$, as a domain declares
a constant singleton subcategory in the codomain.
A constant functor, $\funct{c}$, for an object, $\obk{c}$, maps
the terminal category, $\catN{1}$, to a singleton category, $\singletoncat{c}$.

\begin{equation}\label{eq:singletonfunct}
  \mapaob{\catN{1}}{\parsecat{c}}{\singletoncat{c}}
\end{equation}

A constant UMP, $\umpconst{c}$, defines a mapping of a domain category,
$\parsecat{C}$, to a codomain singleton category, $\singletoncat{c}$.
Essentially all objects and arrows of the category, $\parsecat{C}$,
respectively map to the unique object and arrow of the singleton category,
$\singletoncat{c}$.

\begin{equation}\label{eq:singletonfunct}
  \mapaob{\parsecat{C}}{\forall_{\obk{c}}}{\singletoncat{c}}
\end{equation}

The constant functor is defines a universal proposition, $\forall$, of the
codomain object in the context of the domain category.

The embeding constant UMP, $\umpall$, maps a category to
an associated singleton.

\begin{definition}{Singleton Category, $\singletoncat{c}$}
  \label{def:singletoncategoryplus},
\begin{equation}\label{eq:singletonfunct}
  \mapaob{\parsecat{C}}{\forall}{\singletoncat{C}}
\end{equation}
\begin{equation*}
\begin{array}{llll}
\quad\bullet\quad&\wrpcobj{\singletoncat{C}}&=&\{\pazocal{C}\} \\[3pt]
\quad\bullet\quad&\wrpcarr{\singletoncat{C}}&=&\{\oper{id}_{\pazocal{C}}\}
\end{array}
\end{equation*}
\end{definition}

\subsubsection{Relations}

A relation is a characteristic of an arrow, definition \ref{def:collection}.
As such an arrow is a specialized object attributed as a relation from an
associated domain to a codomain object.
Special relations were introduced in the definition of
collections and categories, designated by operators, $\oper{rel}$,
$\oper{dom}$, $\oper{cod}$, $\oper{obk}$ and $\oper{arr}$.
The identity relation distinguishes a collection of
self relation arrows acting on category objects.
The identity relation existentially identifies an object or
qualifies that a the associated object is unknown within a target
collection.
In the previous section initial and terminal arrows are special
relations with initial domain and terminal codomain objects, respectively.
Functors extended the concept of relations to encompass
behavior category consisting of propery objects with
relation arrows that map a domian proerty to a codomain property.
This section focuses on simple relations 
The general, $\oper{rel}$, property of an arrow maps
the class of relations, $\mathcal{R}$ from all arrows of $\largecatarr$. 
This section explores and details properties of relation
classes associated with properties of partial ordering.
Several arrows introduced previously indicate partial order
relations, $\in$, and $\lessdot$ as well as the subcategory
relation, $\gtrdot$. Equivalence relations, $\sim$,
are a stricter form of partial ordering with the addition of a
symmetric property.

Each arrow asssociates a domain and codomain object pair
with a characteristic. The collection of arrow
characteristics is designated as class of relations, $\mathcal{R}$.
Alternately, each relation, $R\in\mathcal{R}$, identifies a class
of arrows within each category of $\functcatcat$. Specifically,
a relation maps each domain/codomain pair, $\cpair{a}{b}\in\ccpair{C}$,
of a collection, $\parsecat{C}$,
into a subcollection of the $\homcat$ object $\carrobj{C}\cpair{a}{b}$.

\begin{definition}{Relation class, $\mathcal{R}$}\label{def:relationclass},
  is a characteristic of arrows.
  Each relation, $R\in\mathcal{R}$, acts on categories,
  $\parsecat{C}\in\largecatobj$, as a mapping of
  domain/codomain pairs, $\cpair{a}{b}\in\ccpair{C}$ into
  a $\homcat$ object, $\carrobj{C}\cpair{a}{b}$. 
  For all $\cpair{a}{b}\in\ccpair{C}$, $\parsecat{C}\in\largecatobj$:
  \begin{itemize}
  \item\textbf{(Mapping)} \\[3pt]
       \begin{equation*}
    \qquad\funct{R}(\carrobj{C}\cpair{a}{b})\lessdot
                \carrobj{C}\cpair{a}{b}
       \end{equation*}
     \item\textbf{(Not Relatable)} A category, $\parsecat{C}$, is not
       relatable, $\funct{R}(\parsecat{C})=\catN{0}$, if:
       \begin{equation*}
    \qquad\funct{R}(\carrobj{C}\cpair{a}{b})=\varnothing \\[3pt]
                \;\text{for any};\cpair{a}{b}\in\ccpair{C}
       \end{equation*}
  \item\textbf{(Relatable)}
       \begin{equation*}
          \begin{array}{rl}
            \funct{R}(&\carrobj{C}\cpair{a}{b}) \\[3pt]
               \lessdot&\left\{\begin{array}{ll}
                           \varnothing &\text{not compatable} \\[3pt]
                          \carrobj{C}\cpair{a}{b} &\text{compatable}
                          \end{array}
         \end{array}
       \end{equation*}
    in general each relation $R\in\mathcal{R}\;$ partitions
    $\ccpair{C}$ into a compatable and not relatable subcollection
    for any category $\parsecat{C}\in\largecatobj$
  \item\textbf{(Strict)} \\[3pt]
    $\funct{R}(\carrobj{C}\cpair{a}{b})=\left\{\begin{array}{ll}
                                 \varnothing &\text{not relatable} \\[3pt]
                                 \{\arr{R}\} &\text{relatable}
                                 \end{array}$ \\[3pt]
    where $\{\arr{R}\}$ is a singleton set.  \\[3pt]
    In shorthand
       \begin{equation*}
                 R\cpair{a}{b}=\left\{\begin{array}{ll}
                  \text{undefined} &\text{not relatable} \\[3pt]
                  \obj{a}R\obj{b} &\text{relatable}
                                      \end{arraay}
       \end{equation*}
  \end{itemize}
\end{definition}

Define a strict relation as a comparison of an object pair relative to
a characteristic of properties. The relation
is either defined as a unique arrow relative to the pair or
undefined. The most general class of strict relations is the
partial ordering, designated as, $\leq$.
A special category, $\largepo$, consists of categories that are
relatable to partial ordering and complete with the properties
stated as follows:

\begin{definition}{Partial Ordering Relation, $\leq\in\mathcal{R}$},
  \label{def:transitive}
  for any category, $\parsecat{C}\in\wrapobj{\largepo}$ implies the
  following for any pairs,
  $\cpair{a}{a},\,\cpair{a}{b},\,\cpair{b}{c}\in\ccpair{C}$:
  \begin{itemize}
\item\textbf{(Antisymmetry,Closure)}
       \begin{equation*}
                 \leq\cpair{a}{b}=\left\{\begin{array}{ll}
                  \obj{a}>\obj{b}&\text{not relatable},\,\nleq \\[3pt]
                  \obj{a}\leq\obj{b} &\text{relatable}
                                       \end{arraay}
       \end{equation*}
       \begin{equation*}
       \text{if}\;\obj{a}\leq\obj{b}\;\text{and}\;\obj{b}\leq\obj{a}
       \Longrightarrow\obj{a}=\obj{b}
       \end{equation*}
\item\textbf{(Reflexive)}
  $\obk{a}\leq\obk{a}\quad\forall\:a\in\catobj{C}$,\,\text{implies} \\[3pt]
  identity arrow for the relation
\item\textbf{(Transitive)} $\obk{a}\leq\obk{b},\,\obk{b}\leq\obk{c}
  \Longrightarrow\obk{a}\leq\obk{c}$,\,\text{implies} \\[3pt]
  commuting arrow composition of the relation
\end{itemize}
\end{definition}

\subsubsection{Partial Order}

Initial, terminal and identity relations demonstrate a distinct
arrows with a partial order characteristic.
Specifically, a partial order arrow is a singleton member of a Hom object
for a the respective domain and codomain object pair.
In summary a partial order relation, $\obk{R}\in\mathcal{R}$,
is a subcollection of arrows for a category or
functor that uniformly consist of singleton Hom objects. 

\begin{definition}{Partial Order}\label{def:relation},
  $\obk{R}\in\mathcal{R}$, over a category, $\parsecat{C}$, is a
  subcategory, $\parsecat{C}_{\obk{R}}\lessdot\parsecat{C}$, such that
  each homomorphic object is a singleton arrow collection,
  $\{\arr{k}\}\in\parsecat{C}_{\obk{R},\rightarrow,\subp{0}}$,
\begin{equation*}
  \{\arr{k}\}\cong\catN{1}\,,\quad\arrdom{k},\,\arrcod{k}\in\ccobj{C}
\end{equation*}
\end{definition}

The inclusion, $\lessdot$, is a monomorphism relation and a partial order.

A partial order with closure, reflexivity and transitivity
properties on a category, $\parsecat{C}\in\wrapobj{\largepo}$,
imply a subcategory, $\csub{\ccrel{C}{\leq}}{C}$.
This follows from the reflexive identity and commuting composition
property of partial order, $\leq$, to support arrow composition,
hence a partial ordering defines a subcategory for any category,
$\parsecat{C}\in\wrapobj{\largepo}$:

\begin{definition}{Partial order subcategory},
  $\leq\in\mathcal{R}$\label{def:partialordersubcat},
  \begin{itemize}
  \item\textbf{(Subcategory)}
    $\funct{\leq}(\parsecat{C})=\csub{\ccrel{C}{R}}{\parsecat{C}}$ \\[3pt]
    for any $\parsecat{C}\in\wrapobj{\largepo}$
  \begin{itemize}
  \item\textbf{(Objects)} $\wrapobj{\ccrel{C}{\leq}}=\ccobj{C}$
  \item\textbf{(Arrows)} 
  \begin{equation*}
  \begin{array}{rl}  
    \hspace{34pt}\wraparr{\ccrel{C}{\leq}}=\{\arr{\leq}\mid
    &\arrdom{\leq}=\obk{a}
           ,\,\arrcod{\leq}=\obk{b}, \\[3pt]
    \quad&\text{for any}\;\obk{a}\leq\obk{b} \\[3pt]
    \quad&\text{and}\;\cpair{a}{b}\in\ccpair{C}\} 
  \end{array}
  \end{equation*}
  \end{itemize}  
  \end{itemize}
\end{definition}

The reflexive partial ordering propery assures all objects of a
partial order have an identity. The transitive property of a
partial order follow from arrow composition.

A repetoire of concrete partial order relations exist.
The most widely applicable is the subcategory relation, $\lessdot$.
Subcategory implies inclusion of properties for class collections
and inclusion of objects for set collections.

Equivalence strictly extends the partial ordering repetoire of
properties with a symmetric propety.
An equivalence relation is generally denoted by, $\sim$.
Equivalence relations partition category objects, $\catobj{C}$
of a category, $\parsecat{C}$ into subcategories.


\begin{definition}{Equivalence, $\funct{\sim}\in\mathcal{R}$}
    \label{def:equivalence} \\[3pt]
%  Equivalence relation $\sim$, \csub{\ccrel{C}{\sim}}{\parsecat{C}}$ \\[3pt]
\begin{itemize}
\item\textbf{(Symmetric)}
  $\obk{a}\sim\obk{b}\Longleftrightarrow\obk{b}\sim\obk{a}$
\item\textbf{(Subcategory)}
  $\funct{\sim}(\parsecat{C})=\csub{\ccrel{C}{\sim}}{\parsecat{C}}$ \\[3pt]
    for any $\parsecat{C}\in\wrapobj{\largepo}$
  \item\textbf{(Partition, Coset)}, for any
    $\parsecat{C}\in\wrapobj{\largeeq}$ \\[3pt]
    $\ccrel{C}{\obk{v}\sim}=\{\obk{a}\mid\obk{v}\sim\obk{a}\:\text{and}\:
    \obk{a}\in\ccobj{C}\},\;\obk{v}\in\ccobj{C}$ \\[3pt]
  $\csub{\ccrel{C}{\obk{v}\sim}}{\parsecat{C}}\;\text{for any}\;
  \obk{v}\in\ccobj{C}$ \\[3pt]
  $\ccrel{C}{\obk{v}\sim}=\ccrel{C}{\obk{w}\sim}
  \Longleftrightarrow\forall\obk{a}\in\ccrel{C}{\obk{v}\sim}\Longleftrightarrow
  \obk{a}\in\ccrel{C}{\obk{w}\sim}$ \\[3pt]
  $\ccrel{C}{\obk{v}\sim}\neq\ccrel{C}{\obk{w}\sim}\Longleftrightarrow
  \forall\obk{a}\in\ccrel{C}{\obk{v}\sim}}\Longrightarrow
  \obk{a}\notin\ccrel{C}{\obk{w}\sim}$
\end{itemize}
\end{definition}

The $\homcat$ objects, $\carrobj{C}\cpair{a}{b}\in\carrobj{C}$,
of the Hom category demonstrate the equivalence coset
partition of the Hom category, $\carr{C}$.

\begin{align*}
  \arr{r}\in\carrobj{C}\cpair{a}{b}\;\text{and}\;
  \arr{r}\in\carrobj{C}\cpair{a^{\prime}}{b^{\prime}} \\[3pt]
  \Longleftrightarrow\obk{a}=\obk{a^{\prime}}\;\text{and}\;
  \obk{b}=\obk{b^{\prime}}\;
  \cpair{a}{b},\,\cpair{a^{\prime}}{b^{\prime}}\in\ccpair{C}
\end{align*}


\begin{definition}{Diagram Functor, $\ofunct{\mathsf{D}}$}
\label{def:diagfunct},
exclusively consists of relations to embed a diagram
category, $\pazocal{J}$, into a target category, $\pazocal{Z}$:
\begin{equation*}
\begin{gathered}
\mapaob{\pazocal{J}}{\mathsf{D}}{\pazocal{Z}}
\end{gathered}
\end{equation*}
\begin{equation*}
\begin{array}{rll}
\ofunct{\mathsf{D}}&=&\ofunct{\mathsf{D}}_{,\obk{R}} \\[3pt]
\pazocal{J}&=&\ofunctdom{\mathsf{D}} \\[3pt]
\pazocal{Z}&=&\ofunctcod{\mathsf{D}}
\end{array}
\end{equation*}
Denote, $\obk{R}\in\mathcal{R}$, as the diagram arrow relation
\end{definition}

\subsubsection{Partial Ordering}

A partial ordering on a category $\pazocal{C}_{\obk{R}}\lessdot\pazocal{C}$,
requires a special class of arrows, $\ccarr{C_R}_{,\obk{R}}$,
$\ccobj{C}$, with a special class
of arrows sharing a distinct relation.
For lack of generality, denote a partial ordering as $(S,\,\alpha)$,
where $S$ is a set and $\alpha$ is a binary ordering operator.
The binary ordering operator is asymmetric, hence for any two
elements, $a,\,b\in S$, $a\alpha b$ and $b\alpha a$ requires
equality $a=b$. The ordering operator also exhibits a transitive
property, establishing partial ordering of elements in the set.
i.e. given $a,\,b,\,c\in S$, $a\alpha b$ and $b\alpha c$ establishes
that $a\alpha c$.

Partial ordering establishes binary operations over a
power set, $\pset{\top}$. The top symbol, $\top$, typically
denotes a universal set, $\Omega$, and bot symbol, $\bot$,
denotes null, $\varnothing$. Partial orderings employ
two binary operations, meet, $\meet$, and, $\join$.

\subsubsection{Cone and Cocone}

Terminal and initial functors elicit concepts
of limit and colimit relative to categories.
Natural categories serve as a tool to direct limit/colimit concepts
for $0-category$ and $1-category$ collections.
Ultimately, products and dual couterparts provide
a foundation for expressive topology and set theory.

Natural categories serve as the framework for cone and cocone
development of limit and colimit costructs.

The cone, $\cone{J}{Z}$, and cocone, $\cocone{J}{Z}$, natural subcategories
are contained within the natural category, $\cnat{J}{Z}$.

\begin{equation*}
\cone{J}{Z},\,\cocone{J}{Z}\lessdot\cnat{J}{Z}
\end{equation*}

Each cone and cocone natural transform is focused on a specific cone
or cocone object, $\obk{z}$, and singleton category,
$\singletoncat{z}\lessdot\pazocal{Z}$, essentialliy a pivot or copivot
for structural analysis. Cone and cocone natural transforms act
on the duality of specific domain and codomain functors.
The functor collections of cone, $\conefunct{J}{Z}$, and cocone,
$\coconefunct{J}{Z}$, categories consist of a diagram functor,
$\funct{\mathsf{D}}$, and a collection of constant functors,
$\ofunct{\pazocal{J}/{\obk{z}}}$. Each constant functor is
discrimitated by a cone or cocone object designated as,
$\obk{z}\in\pazocal{Z}$.

A common diagram functor acts as a cone codomain or a cocone domain.
The index category, $\pazocal{J}$, extablishes a diagram subcategory,
$\ofunct{\mathsf{D}}(\pazocal{J})$, in the analysis category, $\pazocal{Z}$.

\begin{definition}{Cone/Cocone, Diagram Functor, $\ofunct{\mathsf{D}}$},
  \label{def:co-coconediagram} embeds a domain index category, $\pazocal{J}$,
  into a codomain category, $\pazocal{Z}$.
\begin{equation*}
\begin{array}{rll}
  \pazocal{J}&=&\ofunctdom{\mathsf{D}} \\[3pt]
  \pazocal{Z}&=&\ofunctcod{\mathsf{D}}
\end{array}
\end{equation*}
\begin{equation*}
\mapaob{\pazocal{J}}{\mathsf{D}}{\ofunct{\mathsf{D}}(\pazocal{J})}
\lessdot\pazocal{Z}
\end{equation*}

Each index, $\obk{i}\in\ccobj{J}$, uniquely identifies a codomain object in,
$\pazocal{Z}$. Relations extend as
well from arrows, $\arr{h_{ij}}\in\ccarr{J}$, to arrows,
$\ofunct{\mathsf{D}}(\arr{h_{ij}})\in\ccarr{Z}$:

\begin{equation*}
\begin{array}{rll}
  \obk{i},\,\obk{j}&\in&\pazocal{J}, \\[3pt]
  \arr{h_{ij}}&\in&\carrobj{J}\cpair{i}{j}
\end{array}
\end{equation*}
\begin{equation*}
  \mapaob{\obk{i}}{\obk{h_{ij}}}{\obk{j}}
\end{equation*}

The diagram functor maps arrow and objects of the domain, $\pazocal{J}$,
into the codomain, $\parsecat{Z}$, as follows:

\begin{equation*}
  \functV{\mathsf{D}}{\mapaob{\obk{i}}{\obk{h_{ij}}}{\obk{j}}}=
  \mapaob{\functV{\mathsf{D}}{\obk{i}}}
  {\functV{\mathsf{D}}{\obk{h_{ij}}}}{\functV{\mathsf{D}}{\obk{j}}}
\end{equation*}

Pointwise the functor, $\funct{\mathsf{D}}$, consists of first and second order
arrows:

\begin{equation*}
\begin{array}{rll}
  \obk{i},\,\obk{j}&\in&\pazocal{J}, \\[3pt]
  \arr{h_{ij}}&\in&\carrobj{J}\cpair{i}{j} \\[3pt]
  \arr{d_i},\,\arr{d_j}&\in&\wrparr{\funct{\mathsf{D},}}, \\[3pt]
  \oarr{2}{d_{ij}}&\in&\owrparr{2}{\funct{\mathsf{D},}} \\[3pt]
  \arr{d_i}(\obk{i}),\,\arr{d_j}(\obk{j})&\in&
           \wrpobj{\ofunct{\mathsf{D}}(\pazocal{J})}\lessdot\ccobj{Z}, \\[3pt]
  \oarr{2}{d_{ij}}(\arr{h_{ij}})&\in&\wrparr{\ofunct{\mathsf{D}}(\pazocal{J})}
                                      \lessdot\ccarr{Z}
\end{array}
\end{equation*}
where,
\begin{equation*}
\ofunct{\mathsf{D}}(\pazocal{J})\lessdot\pazocal{Z}
\end{equation*}
\end{definition}

A constant functor establishes an index, $\pazocal{J}$, of
arrows relative to the cone/cocone object, $\obj{z}\in\pazocal{Z}$.

\begin{definition}{Cone/Cocone, Constant Functor,
    $\ofunct{\pazocal{J}/{\obk{z}}}$}
  \label{def:co-coconeconstant}, maps a domain category, $\pazocal{J}$,
  into a codomain singleton category, $\singletoncat{\obk{z}}$.

\begin{equation*}
\begin{array}{rll}
  \pazocal{J}&=&\ofunctdom{\pazocal{J}/{\obk{z}}} \\[3pt]
  \singletoncat{\obk{z}}&=&\ofunctdom{\pazocal{J}/\obk{z}}
\end{array}
\end{equation*}
\begin{equation*}
\mapaob{\pazocal{J}}{\pazocal{J}/\obk{z}}{\singletoncat{\obk{z}}}
\lessdot\pazocal{Z}
\end{equation*}

Pointwise the functor, $\ofunct{\pazocal{J}/{\obk{z}}}$, consists of
first and second order arrows:

\begin{equation*}
\begin{array}{rll}
  \obk{i},\,\obk{j}&\in&\pazocal{J}, \\[3pt]
  \arr{h_{ij}}&\in&\carrobj{J}\cpair{i}{j} \\[3pt]
  \arr{u_i},\,\arr{u_j}&\in&\wrparr{\ofunct{\pazocal{J}/{\obk{z}},}}, \\[3pt]
  \oarr{2}{u_{ij}}&\in&\owrparr{2}{\ofunct{\pazocal{J}/{\obk{z}},}} \\[3pt]
  \arr{u_i}(\obk{i}),\,\arr{u_j}(\obk{j})&=&\obk{z}\in
                       \wrpobj{\singletoncat{z,}}\lessdot\ccobj{Z}, \\[3pt]
  \oarr{2}{u_{ij}}(\arr{h_{ij}})&=&\arrid{z}\in
                   \wrparr{\singletoncat{z,}}\lessdot\ccarr{Z}
\end{array}
\end{equation*}
where,
\begin{equation*}
\singletoncat{z}\lessdot\pazocal{Z}
\end{equation*}
\end{definition}

The diagram functor and constant functor extablish a common index relation
between respective arrows to define a cone/cocone natural transform.

The natural cone category, $\cone{J}{Z}$, contains a subcollection of
natural transforms, $\nfunct{\lambda_{\obk{z}}}\in\conenat{J}{Z}$, indexed
by objects, $\obk{z}\in\pazocal{Z}$.
Each natural transform,$\nfunct{\lambda_{\obk{z}}}$, is a cone transform
with a constant functor domain,
$\ofunct{\pazocal{J}/\obk{z}}=\nfunctdom{\lambda_{\obk{z}}}$,
and a diagram functor codomain, 
$\ofunct{\mathsf{D}}=\nfunctcod{\lambda_{\obk{z}}}$,

\begin{definition}{Cone Category,
$\cone{J}{Z}\lessdot\cnat{J}{Z}$},\label{def:cone}
is a natural subcategory with a distinct collection of natural transforms,
each denoted as a cone transform, $\nfunct{\lambda_{\obk{z}}}$.
The cone object, $cone-\obk{z}$, distinguishes each cone transform.
The cone transform $\nfunct{\lambda_{\obk{z}}}\in\conenat{J}{Z}$,
maps a domain constant functor to a codomain diagram functor:

\begin{equation*}
\begin{array}{rll}
  \ofunct{\parsecat{J}/\obk{z}}&=&
          \nfunctdom{\lambda_{\obk{z}}}\in\conefunct{J}{Z} \\[3pt]
  \ofunct{\mathsf{D}}&=&\nfunctcod{\lambda_{\obk{z}}}\in\conefunct{J}{Z}
\end{array}
\end{equation*}

In detail, a second order arrow, $\oarr{2}{\lambda_i}$, of the cone transform,
maps an domain arrow, $\arr{u_i}$, to a codomain arrow, $\arr{d_i}$:

\begin{equation*}
\begin{array}{rll}
  \oarr{2}{\lambda_i}&\in&\nfunct{\lambda_{z}}_{,\obk{2}} \\[3pt]
  \arr{u_i}&=&\oarrdom{2}{\lambda_i}\in
               \wrparr{\ofunct{\parsecat{J}/\obk{z}}} \\[3pt]
  \arr{d_i}&=&\oarrcod{2}{\lambda_i}\in\wrparr{\ofunct{\mathsf{D}}} \\[3pt]
\text{where},\quad&& \\[3pt]
  \obk{i}&=&\arrdom{u_i}=\arrdom{d_i}
\end{array}
\end{equation*}

Each arrow, $\arr{u_i}\in\wrparr{\ofunct{\parsecat{J}/\obk{z},}}$,
 share a common codomain object, $\obk{z}\in\pazocal{Z}$

\begin{equation*}
\begin{gathered}
  \arr{u_i}\in\wrparr{\ofunct{\parsecat{J}/\obk{z},}} \\[3pt]
  \mapaob{\obk{i}}{\obk{u_i}}{\obk{z}}
\end{gathered}
\end{equation*}

Each arrow, $\arr{d_i}\in\wrparr{\ofunct{\mathsf{D},}}$, embeds a diagram
object into the target category, $\pazocal{Z}$:

\begin{equation*}
\begin{gathered}
  \arr{d_i}\in\wrparr{\funct{\mathsf{D}}_,} \\[3pt]
  \mapaob{\obk{i}}{\obk{d_i}}{\mathsf{D}(\obk{i})}
\end{gathered}
\end{equation*}

Overall, each second order arrow, $\oarr{2}{\lambda_i}$ relates,
domain arrow, $\arr{u_i}$, to a codomain arrow, $\arr{d_i}$:

\begin{equation*}
  \mapaob{\obk{u_i}}{\obk{2},\lambda_i}{\obk{d_i}}
\end{equation*}

Note that the index, $\obk{i}\in\ccobj{J}$, associates common
arrows transformed by the cone arrow, $\oarr{2}{\lambda_i}$.
\end{definition}

Expressing a diagram, \ref{eq:conenatural}, for cone arrows,
$\oarr{2}{\lambda_i},\,\oarr{2}{\lambda_j}\in\nfunct{\lambda_{z}}_{,\obk{2}}$:

\begin{equation}\label{eq:conenatural}
\begin{tikzpicture}
       [
            > = stealth, % arrow head style
            shorten > = 1pt, % don't touch arrow head to node
            auto,
%            node distance = 3cm, % distance between nodes
            semithick % line style
%            font=\tiny
       ]
\tikzstyle{every node}=[font=\smaller=3]
\draw [dashed] (-.8,0)
        ellipse (2.2 and .6) node[]
                    at (-2.3,.6) {$\pazocal{J}$};
\draw [dashed] (3.1,-.1)
        ellipse (.6 and 2.5) node[]
                    at (4,-2) {$\pazocal{Z}$};
\node[] (X1) at (-2.2,0) {$\obk{i}$};
\node[] (X2) at (.4,0) {$\obk{j}$};
\node[above right= 1 and 4.5 of X1] (Z1) {$\mathsf{D}(\obk{i})$};
\node[right= 2 of X2] (Z2) {$\mathsf{D}(\obk{j})$};
\node[circle,draw,dashed,below right= .9 and 4.8 of X1]
     (Zz) {$\catN{1}_{\obk{z}}$};
\path[->,bend left] (X1) edge node[above] (D1) {$\obk{d_i}$} (Z1);
\path[->,bend left] (X2) edge node[above] (D2) {$\obk{d_j}$} (Z2);
\path[->,bend right] (X1) edge node[below] (B1) {$\obk{u_i}$} (Zz);
\path[->,bend right] (X2) edge node[below] (B2) {$\obk{u_j}$} (Zz);
\path[->,bend left=10] (Z1) edge node[xshift=.5ex,yshift=-1ex,fill=white]
      {$\mathsf{D}(\obk{h_{ij}})$} (Z2);
\path[double,->,bend left=55] ([xshift=-2ex,yshift=1ex]B1.north)
      edge[double]
      node[below left] {$\obk{2,\lambda_i}$}
          ([xshift=-2ex,yshift=-.5ex]D1.south east);
\path[double,->,bend left=55] ([xshift=-1ex,yshift=0ex]B2.north east)
      edge[double]
      node[below,right] {$\obk{2,\lambda_j}$}
           ([xshift=1ex,yshift=-.5ex]D2.south east);
\end{tikzpicture}
\end{equation}

\begin{equation}\label{eq:conelambda}
\begin{tikzcd}[row sep=3em,column sep=3em,font=\small,%nodes={inner sep=3pt},
    shorten >=-2pt,shorten <=-2pt,
execute at end picture={
        \draw [dashed] (0,1.6)
        ellipse (2.8cm and .6cm) node[]
                    at (-2.6,2.2) {$\pazocal{Z}$};
        \draw [dashed] (0,0)
        ellipse (2.8cm and .6cm) node[]
                    at (-2.6,.6) {$\ofunct{\mathsf{D}}$};
        \draw [dashed] (0,-1.6)
        ellipse (.8cm and .4cm) node[]
                    at (-1.3,-2) {$\ofunct{\pazocal{J}/\obk{z}}$};
          }]
\mathsf{D}(\obk{i}) \arrow[rr, "\mathsf{D}(\obk{h_{ij}})"]
&& \mathsf{D}(\obk{j}) \\
\obk{d_i} && \obk{d_j} \\
& \fpair{u_i}{u_j} \arrow[ul,yshift=-1ex,"\obk{2,\lambda_i}"]
\arrow[ur,yshift=-1ex,"\obk{2,\lambda_j}"']  &
\end{tikzcd}
\end{equation}

The diagram, \ref{eq:conenatural}, delineates the mapping of a second order
arrow, $\oarr{2}{\lambda_i}\in\nfunct{\lambda_{\obk{z}},}_{\obk{2}}$.

The domain/codomain pair, $\arr{u_i}$ and $\arr{d_i}$, of the second order
arrow, $\oarr{2}{\lambda_i}$, with definition, \ref{def:arrowarrowindex},
support parameterization as a second order Hom index:

\begin{equation}\label{eq:hom2pivot}
   \cpair{\cpair{\obk{i}}{\obk{z}}}{\cpair{\obk{i}}{\mathsf{D}(\obk{i})}}
   =\nprojection{2}\,\nproj\oarr{2}{\lambda_i}
\end{equation}

Equivalently from the definition, \ref{def:arrowarrowindex},
the second order arrow is expressable as two first order arrows,

\begin{equation*}
\oarr{2}{\lambda_i}=
\fpair{\arr{\lambda_{\oper{fst},i}}}{\arr{\lambda_{\oper{snd},i}}}
\end{equation*}

The condition for a pivot projection, Theorem \ref{thm:pivotprojection},
qualifies the reduction of the
second order arrow, $\oarr{2}{\lambda_i}$, to a first order arrow,
$\arr{\lambda_i}$.
For convenience the projections, $\oprojection{\shortleftarrow}{1}$ and,
$\oprojection{\shortrightarrow}{1}$ elaborate the pivot projection action:

\begin{equation*}
\begin{array}{rll}
\arr{\lambda_{\oper{fst},i}}&=&\nprojfst{1}{\oarr{2}{\lambda_i}} \\[3pt]
\arr{\lambda_{\oper{snd},i}}&=&\nprojsnd{1}{\oarr{2}{\lambda_i}} \\[3pt]
\obk{i}=\arrcod{\lambda_{\oper{fst},i}}&&
\obk{i}=\arrcod{\lambda_{\oper{fst},i}} \\[3pt]
\obk{z}=\arrdom{\lambda_{\oper{snd},i}}&&
\mathsf{D}(\obk{i})=\arrcod{\lambda_{\oper{snd},i}}
\end{array}
\end{equation*}

The first arrow, $\arr{\lambda_{\oper{fst},i}}$, having identical domain/codomain,
$\obk{i}$, is equivalently and essentially the identity arrow, $\arrid{i}$,
in the construction, otherwise the theorem cannot be applied.

\begin{equation*}
\arrid{i}=\arr{\lambda_{\oper{fst},i}}
\end{equation*}

The second arrow, $\arr{\lambda_{\oper{snd},i}}$, with domain/codomain,
$\obk{z}$ and $\mathsf{D}(\obk{i})$ respectively, holds singular significance.

\begin{equation*}
\oarr{2}{\lambda_i}=
\fpair{\arrid{i}}{\arr{\lambda_{\oper{snd},i}}}
\end{equation*}

Subsequently, the action of natural transform, $\nfunct{\lambda_{\obk{z}}}$,
projects to a functor, $\funct{\lambda_{\obk{z}}}$:

\begin{equation*}
\funct{\lambda_{\obk{z}}}=\nfunct{\pi_2}(\oarr{2}{\lambda_i})
\end{equation*}

with an initial functor mapping from domain, $\obk{z}$:

\begin{equation*}
\mapaob{\singletoncat{z}}{\lambda_{\obk{z}}}{\mathsf{D}(\pazocal{J})}
\end{equation*}
\begin{equation*}
\forall\arr{\lambda_i}\in\funct{\lambda_{\obk{z}}}\quad
\mapaob{\obk{z}}{\lambda_i}{\mathsf{D}(\obk{i})}
\end{equation*}

A reduced diagram, \ref{eq:kappalimit}, follows.

\begin{equation}\label{eq:kappalimit}
\begin{tikzcd}[row sep=2em, column sep=2em,font=\small,
execute at end picture={
        \draw [dashed] (0,-.05)
        ellipse (2.8cm and .6cm) node[]
                    at (-2.6,-.6) {$\funct{\kappa}$};
          }]
& \mathsf{D}(\obk{i}) & \\
\obk{z^{\prime}} \arrow[rr,"\kappa^{\prime}"']
\arrow[ur,"\obk{\lambda^{\prime}_i}"] &&
\obk{z} \arrow[ul,"\obk{\lambda_i}"'] \\
\obk{z^{\prime}} \arrow[rr,"\obk{\kappa^{\prime}}"] &&  \obk{z}
\end{tikzcd}
\end{equation}

A collection of cones entertains the possibility of extremum or limit.
The concept of a special terminal object or singleton, $\singletoncat{z}$, to
the functor and natural transforms of a cone category, $\cone{J}{Z}$
with additional transform apparatus embodies a limit.
Consider a collection of cone-object indices, $\obk{z^{\prime}}\in\pazocal{Z}$,
the limit requires that every cone, $\nfunct{\lambda_{\obk{z^{\prime}}}}$,
has is the codomain of a higher order natural transform,
$\nfunct{*,\kappa^{\prime}}$ mapping to a limit cone,
$\nfunct{\lambda_{\obk{z}}}$:

\begin{equation*}
  \mapaob{\nfunct{\lambda_{\obk{z^{\prime}}}}}{*,\kappa^{\prime}}
  {\nfunct{\lambda_{\obk{z}}}}
\end{equation*}

Defining the limit in more detail as follows:

\begin{definition}{Limit Cone,
    $\nfunct{\lambda_{\obk{z}}}\in\conenat{J}{Z}$}\label{def:limitcone},
exists such that any other cone,
$\nfunct{\lambda_{\obk{z^{\prime}}}}\in\conenat{J}{Z}$, associates
a higher order transform,
$\nfunct{*,\kappa^{\prime}}\in\wrpnat{\cone{J}{Z}_{*,}}$,
where, $*$, denotes a mapping of natural transforms, such that:
\begin{equation*}
\begin{array}{rll}
  \nfunct{\lambda_{\obk{z^{\prime}}}}&=&\nfunctdom{*,\kappa^{\prime}}} \\[3pt]
  \nfunct{\lambda_{\obk{z}}}&=&\nfunctcod{*,\kappa^{\prime}}}
\end{array}
\end{equation*}
\begin{equation}\label{eq:natconelimit}
  \mapaob{\nfunct{\lambda_{\obk{z^{\prime}}}}}
  {*,\kappa^{\prime}}{\nfunct{\lambda_{\obk{z}}}}
\end{equation}
\end{definition}

\begin{equation}\label{eq:conelimitnatural}
\begin{tikzpicture}
       [
            > = stealth, % arrow head style
            shorten > = 1pt, % don't touch arrow head to node
            auto,
%            node distance = 3cm, % distance between nodes
            semithick % line style
%            font=\tiny
       ]
\tikzstyle{every node}=[font=\smaller=3]
\draw [dashed] (3.1,-.1)
        ellipse (.6 and 2.5) node[]
                    at (4,-2) {$\pazocal{Z}$};
\node[] (J) at (-2.4,.6) {$\pazocal{J}$};
\node[circle,draw,dashed] (X1) at (-2.2,0) {$\obk{i}$};
\node[above right= 1 and 4.8 of X1] (Z1) {$\mathsf{D}(\obk{i})$};
\node[circle,draw,dashed,above right= .1 and 4.8 of X1]
     (Zz) {$\catN{1}_{\obk{z}}$};
\node[circle,draw,dashed,below right= .9 and 4.8 of X1]
     (Zp) {$\catN{1}_{\obk{z^{\prime}}}$};
\path[->,bend left] (X1) edge node[above] (D1) {$\obk{d_i}$} (Z1);
\path[->,bend right] (X1) edge node[below right] (Bz) {$\obk{u_i}$} (Zz);
\path[->,bend right] (X1) edge node[below left] (Bp) {$\obk{u^{\prime}_i}$} (Zp);
\path[double,->,bend right=30] ([xshift=1ex,yshift=2ex]Bz.north east)
      edge[double]
      node[right] (Lz) {$\obk{2,\lambda_i}$}
      ([xshift=0ex,yshift=0ex]D1.south east);
\path[double,->,bend left=30] ([xshift=1ex,yshift=2ex]Bp.north west)
      edge[double]
      node[below left] (Lp) {$\obk{2,\lambda^{\prime}_i}$}
      ([xshift=1ex,yshift=0ex]D1.south);
\path[double,->,fill=black,width=3pt,bend left=10] ([xshift=1ex,yshift=0ex]Lp.north east)
      edge[double]
      node[below] (Kp) {$\obk{3,\kappa^{\prime}_i}$}
      ([xshift=0ex,yshift=1ex]Lz.south west);
\end{tikzpicture}
\end{equation}

The cone limit, $\nfunct{\lambda_{\obk{z}}}$, \ref{eq:natconelimit},
enlists a
collection of higher order natural transforms,
$\nfunct{*,\kappa^{\prime}}\in\wrpnat{\cone{J}{Z}_{*,}}$.
As such, analysis exposes the option of employing a copivot projection,
Corollary \ref{cor:copivotprojection}, as applied to the cone transform.
Henceforth consider the third order arrow,
$\oarr{3}{\kappa^{\prime}_i}\in\nfunctdom{*,\kappa^{\prime}}_{,\obk{3}}$,
which fulfills a mapping:

\begin{equation}\label{eq:conelimittrans}
  \mapaob{\oarr{2}{\lambda^{\prime}_i}}
  {\obk{3},\kappa^{\prime}_i}{\oarr{2}{\lambda_i}}
\end{equation}

The domain and codomain second order arrows, $\oarr{2}{\lambda^{\prime}_i}$ and
$\oarr{2}{\lambda_i}$, share a common codomain, $\arr{d_i}$, diagram arrow,
figure \ref{eq:conelimitnatural}, are reduced to second order arrows  with
the copivot projection, diagram \ref{eq:pairkappalimit}.

\begin{equation}\label{eq:pairkappalimit}
\begin{tikzcd}[row sep=2em, column sep=2em,font=\small,
execute at end picture={
        \draw [dashed] (0,-.05)
        ellipse (2.8cm and .6cm) node[]
                    at (-2.6,-.6) {$\nfunct{\kappa}$};
          }]
& \fpair{d_i}{d_j} & \\
\fpair{u^{\prime}_i}{u^{\prime}_j}
\arrow[rr,"\obk{2}\text{,}\fpair{\kappa^{\prime}_i}{\kappa^{\prime}_j}"']
\arrow[ur,"\obk{2}\text{,}\fpair{\lambda^{\prime}_i}{\lambda^{\prime}_j}"] &&
\fpair{u_i}{u_j} \arrow[ul,"\obk{2}\text{,}\fpair{\lambda_i}{\lambda_j}"'] \\
\singletoncat{z^{\prime}}
       \arrow[rr,"\obk{\kappa^{\prime}}"] &&  \singletoncat{z}
\end{tikzcd}
\end{equation}

As required by the corollary, \ref{cor:copivotprojection}, the
common codomain, diagram arrows, $\arr{d_i}\in\wrparr{\ofunct{\mathsf{D},}}$,
eq. \ref{eq:conelimitnatural}, reduces the mapping of a third order arrow to a
composition of second order arrows:

\begin{equation}\label{eq:conelimittranscompose}
  \oarr{2}{\lambda^{\prime}_i}=\oarr{2}{\lambda_i}\circ\oarr{2}{\kappa^{\prime}_i}
\end{equation}

where,

\begin{equation}\label{eq:conelimittransproj}
  \oarr{2}{\lambda_i}=\oarr{3}{\kappa^{\prime}_i})(\oarr{2}{\lambda^{\prime}_i})
\end{equation}

Expressing the limit reduced by pivot projection with diagram,
\ref{eq:pairkappalimit}, with natural transform, \ref{eq:conelimittransproj}:

\begin{equation}\label{eq:natconelimitcompose}
  \nfunct{\lambda^{\prime}}=\nfunct{\lambda}\circ\nfunct{\kappa^{\prime}}
\end{equation}

Likewise cone transforms are reducible by pivot projection as indexed
by a common object, $\obk{i}\in\pazocal{J}$.
Expression with first order arrows follows:

\begin{equation}\label{eq:conelimittrans}
  \arr{\lambda^{\prime}_i}=\arr{\lambda_i}\circ\arr{\kappa^{\prime}_i}
\end{equation}

where,

\begin{equation}\label{eq:conelimitsingleton}
  \mapaob{\obk{z^{\prime}}}{\kappa^{\prime}}{\obk{z}}
\end{equation}

In general over all diagram objects a projected functor transform
is expressed:

\begin{equation}\label{eq:conelimittransproj}
  \funct{\lambda^{\prime}}=\funct{\lambda}\circ\funct{\kappa^{\prime}}
\end{equation}

The dual of the cone and limit are the cocone and colimit.
The natural cocone category, $\cocone{J}{Z}$, contains a subcollection of
natural transforms, $\nfunct{\lambda_{\obk{z}}}\in\coconenat{J}{Z}$, indexed
by objects, $\obk{z}\in\pazocal{Z}$.
Each natural transform,$\nfunct{\lambda_{\obk{z}}}$, is a cocone transform
with a diagram functor domain, 
$\ofunct{\mathsf{D}}=\nfunctcod{\lambda_{\obk{z}}}$,
and a constant functor codomain,
$\ofunct{\pazocal{J}/\obk{z}}=\nfunctdom{\lambda_{\obk{z}}}$,

\begin{definition}{Cocone Category,
$\cocone{J}{Z}\lessdot\cnat{J}{Z}$},\label{def:cocone}
is a natural subcategory with a distinct collection of natural transforms,
each denoted as a cocone transform, $\nfunct{\lambda_{\obk{z}}}$.
The cocone object, $cocone-\obk{z}$, distinguishes each cocone transform.
The cocone transform $\nfunct{\lambda_{\obk{z}}}\in\coconenat{J}{Z}$,
maps a domain constant functor to a codomain diagram functor:

\begin{equation*}
\begin{array}{rll}
  \ofunct{\mathsf{D}}&=&\nfunctdom{\lambda_{\obk{z}}}
                         \in\coconefunct{J}{Z} \\[3pt]
  \ofunct{\parsecat{J}/\obk{z}}&=&
          \nfunctcod{\lambda_{\obk{z}}}\in\coconefunct{J}{Z} \\[3pt]
\end{array}
\end{equation*}

In detail, a second order arrow, $\oarr{2}{\lambda_i}$, of the cocone transform,
maps an domain arrow, $\arr{d_i}$, to a codomain arrow, $\arr{u_i}$:

\begin{equation*}
\begin{array}{rll}
  \oarr{2}{\lambda_i}&\in&\nfunct{\lambda_{z}}_{,\obk{2}} \\[3pt]
  \arr{d_i}&=&\oarrdom{2}{\lambda_i}\in
               \wrparr{\ofunct{\mathsf{D},}} \\[3pt]
  \arr{u_i}&=&\oarrcod{2}{\lambda_i}
               \in\wrparr{\ofunct{\parsecat{J}/\obk{z},}} \\[3pt]
\text{where},\quad&& \\[3pt]
  \obk{i}&=&\arrdom{u_i}=\arrdom{d_i}
\end{array}
\end{equation*}

Each arrow, $\arr{u_i}\in\wrparr{\ofunct{\parsecat{J}/\obk{z},}}$,
share a common codomain object, $\obk{z}\in\pazocal{Z}$

\begin{equation*}
\begin{gathered}
  \arr{u_i}\in\wrparr{\ofunct{\parsecat{J}/\obk{z},}} \\[3pt]
  \mapaob{\obk{i}}{\obk{u_i}}{\obk{z}}
\end{gathered}
\end{equation*}

Each arrow, $\arr{d_i}\in\wrparr{\ofunct{\mathsf{D},}}$, embeds a diagram
object into the target category, $\pazocal{Z}$:

\begin{equation*}
\begin{gathered}
  \arr{d_i}\in\wrparr{\funct{\mathsf{D}}_,} \\[3pt]
  \mapaob{\obk{i}}{\obk{d_i}}{\mathsf{D}(\obk{i})}
\end{gathered}
\end{equation*}

Overall, each second order arrow, $\oarr{2}{\lambda_i}$ relates,
domain arrow, $\arr{d_i}$, to a codomain arrow, $\arr{u_i}$:

\begin{equation*}
  \mapaob{\obk{d_i}}{\obk{2},\lambda_i}{\obk{u_i}}
\end{equation*}

Note that the index, $\obk{i}\in\ccobj{J}$, associates common
arrows transformed by the second order cocone arrow, $\oarr{2}{\lambda_i}$.
\end{definition}

Expressing a diagram, \ref{eq:coconenatural}, for second order cocone arrows,
$\oarr{2}{\lambda_i},\,\oarr{2}{\lambda_j}\in\nfunct{\lambda_{z}}_{,\obk{2}}$:

\begin{equation}\label{eq:coconenatural}
\begin{tikzpicture}
       [
            > = stealth, % arrow head style
            shorten > = 1pt, % don't touch arrow head to node
            auto,
%            node distance = 3cm, % distance between nodes
            semithick % line style
%            font=\tiny
       ]
\tikzstyle{every node}=[font=\smaller=3]
\draw [dashed] (-.8,0)
        ellipse (2.2 and .6) node[]
                    at (-2.3,.6) {$\pazocal{J}$};
\draw [dashed] (3,-.1)
        ellipse (.6 and 2.5) node[]
                    at (4,-2) {$\pazocal{Z}$};
\node[] (X1) at (-2.2,0) {$\obk{i}$};
\node[] (X2) at (.4,0) {$\obk{j}$};
\node[above right= 1 and 4.5 of X1] (Z1) {$\mathsf{D}(\obk{i})$};
\node[right= 2 of X2] (Z2) {$\mathsf{D}(\obk{j})$};
\node[circle,draw,dashed,below right= .9 and 4.8 of X1]
     (Zz) {$\catN{1}_{\obk{z}}$};
\path[->,bend left] (X1) edge node[above] (D1) {$\obk{d_i}$} (Z1);
\path[->,bend left] (X2) edge node[above] (D2) {$\obk{d_j}$} (Z2);
\path[->,bend right] (X1) edge node[below] (B1) {$\obk{u_i}$} (Zz);
\path[->,bend right] (X2) edge node[below] (B2) {$\obk{u_j}$} (Zz);
\path[->,bend left=10] (Z1) edge node[xshift=.5ex,yshift=-1ex,fill=white]
      {$\mathsf{D}(\obk{h_{ij}})$} (Z2);
\path[double,->,bend right=55] ([xshift=-2ex,yshift=-.5ex]D1.south east)
      edge[double]
      node[below left] {$\obk{2,\lambda_i}$} ([xshift=-2ex,yshift=1ex]B1.north);
\path[double,->,bend right=55] ([xshift=1ex,yshift=-.5ex]D2.south east)
      edge[double]
      node[below,right] {$\obk{2,\lambda_j}$}
          ([xshift=-1ex,yshift=0ex]B2.north east);
\end{tikzpicture}
\end{equation}

\begin{equation}\label{eq:coconelambda}
\begin{tikzcd}[row sep=3em,column sep=3em,font=\small,%nodes={inner sep=3pt},
    shorten >=-2pt,shorten <=-2pt,
execute at end picture={
        \draw [dashed] (0,1.6)
        ellipse (2.8cm and .6cm) node[]
                    at (-2.6,2.2) {$\pazocal{Z}$};
        \draw [dashed] (0,0)
        ellipse (2.8cm and .6cm) node[]
                    at (-2.6,.6) {$\ofunct{\mathsf{D}}$};
        \draw [dashed] (0,-1.6)
        ellipse (.8cm and .4cm) node[]
                    at (-1.3,-2) {$\ofunct{\pazocal{J}/\obk{z}}$};
          }]
\mathsf{D}(\obk{i}) \arrow[rr, "\mathsf{D}(\obk{h_{ij}})"]
&& \mathsf{D}(\obk{j}) \\
\obk{d_i} \arrow[dr,yshift=-1ex,"\obk{2,\lambda_i}"] &&
\obk{d_j} \arrow[dl,yshift=-1ex,"\obk{2,\lambda_j}"'] \\
& \fpair{u_i}{u_j}  &
\end{tikzcd}
\end{equation}

Considering the dual of the diagram, \ref{eq:coconenatural},
delineates an example of the second order
arrow, $\oarr{2}{\lambda_i}\in\nfunct{\lambda_{\obk{z}},}_{\obk{2}}$.

The domain/codomain pair, $\arr{d_i}$ and $\arr{u_i}$, of the second order
arrow, $\oarr{2}{\lambda_i}$, is parameterized as a second order Hom index,
recall definition \ref{def:arrowarrowindex}:

\begin{equation}\label{eq:hom2pivot}
   \oarr{2}{\lambda_i}\in\nfunct{\lambda_{\obk{z}}}
  \cpair{\cpair{\obk{i}}{\obk{i}}}
  {\cpair{\mathsf{D}(\obk{i})}{\obk{z}}}_{\obk{2}}
\end{equation}

Equivalently from the definition, \ref{def:arrowarrowindex},
the second order arrow is expressable as two first order arrows,

\begin{equation*}
\oarr{2}{\lambda_i}=
\fpair{\arr{\lambda_{\oper{dom},i}}}{\arr{\lambda_{\oper{cod},i}}}
\end{equation*}

The condition for a pivot projection, theorem \ref{thm:pivotprojection},
qualifies the reduction of the
second order arrow, $\oarr{2}{\lambda_i}$, to a first order arrow,
$\arr{\lambda_i}$.
For convenience the natural transforms, $\nfunct{\pi_1}$ and,
$\nfunct{\pi_2}$ elaborate the pivot projection action:

\begin{equation*}
\begin{array}{rll}
\arr{\lambda_{\oper{dom},i}}&=&\nfunct{\pi_1}(\oarr{2}{\lambda_i}) \\[3pt]
\arr{\lambda_{\oper{cod},i}}&=&\nfunct{\pi_2}(\oarr{2}{\lambda_i}) \\[3pt]
\obk{i}=\arrdom{\lambda_{\oper{dom},i}}&&
\obk{i}=\arrcod{\lambda_{\oper{dom},i}} \\[3pt]
\mathsf{D}(\obk{i})=\arrdom{\lambda_{\oper{cod},i}}&&
\obk{z}=\arrcod{\lambda_{\oper{cod},i}}
\end{array}
\end{equation*}

The first arrow, $\arr{\lambda_{\oper{dom},i}}$, with identical domain/codomain,
$\obk{i}$, is equivalently and essentially the identity arrow, $\arrid{i}$,
in the construction, otherwise the theorem cannot be applied.

\begin{equation*}
\arrid{i}=\arr{\lambda_{\oper{dom},i}}
\end{equation*}

The second arrow, $\arr{\lambda_{\oper{cod},i}}$, with domain/codomain,
$\mathsf{D}(\obk{i})$ and $\obk{z}$ respectively, holds singular significance.

\begin{equation*}
\oarr{2}{\lambda_i}=
\fpair{\arrid{i}}{\arr{\lambda_{\oper{cod},i}}}
\end{equation*}

Subsequently, the action of natural transform, $\nfunct{\lambda_{\obk{z}}}$,
projects to a functor, $\funct{\lambda_{\obk{z}}}$:

\begin{equation*}
\arr{\lambda_i}=\nfunct{\pi_2}(\oarr{2}{\lambda_i})
\end{equation*}

with an initial functor mapping from domain, $\mathsf{D}(\pazocal{J})$:

\begin{equation*}
\mapaob{\mathsf{D}(\pazocal{J})}{\lambda_{\obk{z}}}{\singletoncat{z}}
\end{equation*}
\begin{equation*}
\forall\;\obk{i}\in\ccobj{J},\,\arr{\lambda_i}\in\funct{\lambda_{\obk{z}}}
\quad\mapaob{\mathsf{D}(\obk{i})}{\lambda_i}{\obk{z}}
\end{equation*}

%%new colimit
A collection of cocones entertains the possibility of extremum or colimit.
The concept of a special initial or empty object, $\catN{0}$ represents
an ultimate extremum, a dual to the terminal object, $\catN{1}$.
The functor and natural transforms of a cocone category, $\cocone{J}{Z}$
with additional transform apparatus embodies a colimit.
Consider a collection of cocone-object indices, $\obk{z^{\prime}}\in\pazocal{Z}$,
the limit requires that every cocone, $\nfunct{\lambda_{\obk{z^{\prime}}}}$,
is the codomain of a higher order natural transform,
$\nfunct{*,\kappa^{\prime}}$ mapping from a domain colimit cocone,
$\nfunct{\lambda_{\obk{z}}}$:

\begin{equation*}
  \mapaob{\nfunct{\lambda_{\obk{z}}}}{*,\kappa^{\prime}}
  {\nfunct{\lambda_{\obk{z^{\prime}}}}}
\end{equation*}

Defining the colimit in more detail as follows:

\begin{definition}{Colimit Cocone,
    $\nfunct{\lambda_{\obk{z}}}\in\coconenat{J}{Z}$}\label{def:colimitcocone},
exists such that any other cocone,
$\nfunct{\lambda_{\obk{z^{\prime}}}}\in\coconenat{J}{Z}$, associates
a higher order transform,
$\nfunct{*,\kappa^{\prime}}\in\wrpnat{\cone{J}{Z}_{*,}}$,
where, $*$, denotes a mapping of natural transforms, such that:
\begin{equation*}
\begin{array}{rll}
  \nfunct{\lambda_{\obk{z}}}&=&\nfunctdom{*,\kappa^{\prime}}} \\[3pt]
  \nfunct{\lambda_{\obk{z^{\prime}}}}&=&\nfunctcod{*,\kappa^{\prime}}}
\end{array}
\end{equation*}
\begin{equation}\label{eq:natcoconecolimit}
  \mapaob{\nfunct{\lambda_{\obk{z}}}}
  {*,\kappa^{\prime}}{\nfunct{\lambda_{\obk{z^{\prime}}}}}
\end{equation}
\end{definition}

\begin{equation}\label{eq:coconecolimitnatural}
\begin{tikzpicture}
       [
            > = stealth, % arrow head style
            shorten > = 1pt, % don't touch arrow head to node
            auto,
%            node distance = 3cm, % distance between nodes
            semithick % line style
%            font=\tiny
       ]
\tikzstyle{every node}=[font=\smaller=3]
\draw [dashed] (3.1,-.1)
        ellipse (.6 and 2.5) node[]
                    at (4,-2) {$\pazocal{Z}$};
\node[] (J) at (-2.4,.6) {$\pazocal{J}$};
\node[circle,draw,dashed] (X1) at (-2.2,0) {$\obk{i}$};
\node[above right= 1 and 4.8 of X1] (Z1) {$\mathsf{D}(\obk{i})$};
\node[circle,draw,dashed,above right= .1 and 4.8 of X1]
     (Zz) {$\catN{1}_{\obk{z}}$};
\node[circle,draw,dashed,below right= .9 and 4.8 of X1]
     (Zp) {$\catN{1}_{\obk{z^{\prime}}}$};
\path[->,bend left] (X1) edge node[above] (D1) {$\obk{d_i}$} (Z1);
\path[->,bend right] (X1) edge node[below right] (Bz) {$\obk{u_i}$} (Zz);
\path[->,bend right] (X1) edge node[below left] (Bp) {$\obk{u^{\prime}_i}$} (Zp);
\path[double,->,bend left=30] ([xshift=0ex,yshift=0ex]D1.south east)
      edge[double]
      node[right] (Lz) {$\obk{2,\lambda_i}$}
      ([xshift=1ex,yshift=2ex]Bz.north east);
\path[double,->,bend right=30] ([xshift=1ex,yshift=0ex]D1.south)
      edge[double]
      node[below left] (Lp) {$\obk{2,\lambda^{\prime}_i}$}
      ([xshift=1ex,yshift=2ex]Bp.north west);
\path[double,->,fill=black,width=3pt,bend right=10]
      ([xshift=-.5ex,yshift=1ex]Lz.south west)
      edge[double]
      node[below] (Kp) {$\obk{3,\kappa^{\prime}_i}$}
      ([xshift=.5ex,yshift=0ex]Lp.north east);
\end{tikzpicture}
\end{equation}

The cocone colimit, $\nfunct{\lambda_{\obk{z}}}$, \ref{eq:natcoconecolimit},
enlists a
collection of higher order natural transforms,
$\nfunct{*,\kappa^{\prime}}\in\wrpnat{\cocone{J}{Z}_{*,}}$.
As such, analysis exposes the option of employing a pivot projection,
theorem \ref{thm:pivotprojection}, as applied to the cocone transform.
Henceforth consider the third order arrow,
$\oarr{3}{\kappa^{\prime}_i}\in\nfunctdom{*,\kappa^{\prime}}_{,\obk{3}}$,
which fulfills a mapping:

\begin{equation}\label{eq:coconecolimittrans}
  \mapaob{\oarr{2}{\lambda_i}}
  {\obk{3},\kappa^{\prime}_i}{\oarr{2}{\lambda^{\prime}_i}}
\end{equation}

The domain and codomain second order arrows, $\oarr{2}{\lambda_i}$ and
$\oarr{2}{\lambda^{\prime}_i}$, share a common domain, $\arr{d_i}$,
diagram arrow,
figure \ref{eq:coconecolimitnatural}, are reduced to second order arrows  with
the pivot projection, diagram \ref{eq:kappacolimit}.

\begin{equation}\label{eq:kappacolimit}
\begin{tikzcd}[row sep=2em, column sep=2em,font=\small,
execute at end picture={
        \draw [dashed] (0,-.05)
        ellipse (2.8cm and .6cm) node[]
                    at (-2.6,-.6) {$\nfunct{\kappa}$};
          }]
& \fpair{d_i}{d_j} \arrow[dl,"\obk{2}\text{,}\fpair{\lambda_i}{\lambda_j}"']
\arrow[dr,"\obk{2}\text{,}\fpair{\lambda^{\prime}_i}{\lambda^{\prime}_j}"] & \\
\fpair{u_i}{u_j}
\arrow[rr,"\obk{2}\text{,}\fpair{\obk{\kappa^{\prime}_i}}{\obk{\kappa^{\prime}_j}}"'] &&
\fpair{u^{\prime}_i}{u^{\prime}_j} \\
\singletoncat{z} \arrow[rr,"\obk{\kappa^{\prime}}"] &&
\singletoncat{z^{\prime}}
\end{tikzcd}
\end{equation}

As required by the theorem, \ref{thm:pivotprojection}, the
common domain, diagram arrows, $\arr{d_i}\in\wrparr{\ofunct{\mathsf{D},}}$,
eq. \ref{eq:coconecolimitnatural}, reduces the mapping of a
third order arrow to a composition of second order arrows:

\begin{equation}\label{eq:coconecolimittranscompose}
  \oarr{2}{\lambda^{\prime}_i}=\oarr{2}{\kappa^{\prime}_i}\circ\oarr{2}{\lambda_i}
\end{equation}

where,

\begin{equation}\label{eq:coconecolimittransproj}
  \oarr{2}{\kappa^{\prime}_i}\circ\oarr{2}{\lambda_i}=
           \oarr{3}{\kappa^{\prime}_i}(\oarr{2}{\lambda_i})
\end{equation}

Expressing the colimit over the entire diagram with natural transform:

\begin{equation}\label{eq:natcoconecolimitcompose}
  \nfunct{\lambda^{\prime}}=\nfunct{\kappa^{\prime}}\circ\nfunct{\lambda}
\end{equation}

Likewise cocone transforms are reducible by pivot projection as indexed
by a common object, $\obk{i}\in\pazocal{J}$.
Expression with first order arrows follows:

\begin{equation}\label{eq:arrowcoconecolimitcompose}
  \arr{\lambda^{\prime}_i}=\arr{\kappa^{\prime}_i}\circ\arr{\lambda_i}
\end{equation}

where,

\begin{equation}\label{eq:coconecolimitsingleton}
  \mapaob{\obk{z}}{\kappa^{\prime}}{\obk{z^{\prime}}}
\end{equation}

In general over all diagram objects a projected functor transform
is expressed:

\begin{equation}\label{eq:functcoconecolimitcompose}
  \funct{\lambda^{\prime}}=\funct{\kappa^{\prime}}\circ\funct{\lambda}
\end{equation}

with,

\begin{equation}\label{eq:coconecolimitsingleton}
  \mapaob{\singleton{z}}{\kappa^{\prime}}{\singleton{z^{\prime}}}
\end{equation}

As a tool the cone and cocone act as a basis for universal constructs.
A simplex category develops from the recursive applicaton of a cone and cocone
algorithm augmented by initial and terminal inputs. 
The cone and cocone algorhthms derive alternate versions of the simplex
category.

The finite category, $\fincat$, contains the cone and cocone versions of
simplex categories. A finite category relates by isomorphism with
natural numbers, $\mathbb{N}$. An cone or cocone functor successively
extends a domain simplex to a codomain simplex having an additional object
with associated arrows. A recursive functor application derives
a collection of categories isomorphic to the natural numbers, $\mathbb{N}$.
The size or cardinality of a simplex category denotes the count of objects.

The initial category represents the initial condition of the simplex algorithm.
The initial simplex has no objects.

\begin{equation}\label{eq:initialsimplex}
  \simplex{0}=\catN{0}
\end{equation}

A special constant functor for simplex construction,
denoted as $\funct{\gtrdot}$, embeds a domain
category, $\pazocal{C}$, into a self defined singleton, $\singletoncat{C}$:

\begin{equation}\label{eq:constantsimplex}
  \mapaob{\pazocal{C}}{\gtrdot}{\singletoncat{C}}
\end{equation}

Applied to the initial simplex the result shows

\begin{equation}\label{eq:onesimplex}
  \mapaob{\simplex{0}}{\gtrdot}{\singleton{\simplex{0}}}\lessdot\simplex{1}
\end{equation}

Continuing with the cone/cocone embedding,
an empty diagram, $\simplex{0}$, embeds trivally into the codomain,
$\simplex{1}$.

\begin{equation}\label{eq:diagramsimplex}
  \mapaob{\simplex{0}}{\mathsf{D}}{\simplex{1}}
\end{equation}

For the, $\simplex{1}$, mapping the cone or cocone natural transform,
$\nfunct{\lambda}$, is trivial. Higher order
interations prove differently. The natural transform requires a distinction
between cone and cocone simplexes of $n$ iterations, $\simplex{n}$ and
$\simplex{n}$, respectively.

Combining equations, \ref{eq:constantsimplex}, \ref{eq:diagramsimplex}
and with the natural transform completes the simplex algorithm.

\begin{equation}\label{eq:allsimplex}
\begin{gathered}
  \mapaob{\simplex{n}}{\mathsf{\gtrdot}}{\singleton{\simplex{n}}}
           \lessdot\simplex{n+1} \\[3pt]
  \mapaob{\simplex{n}}{\mathsf{D}}{\simplex{n+1}} \\[3pt]
  \mapaob{\singleton{\simplex{n}}}{\obk{\lambda_n}}
  {\mathsf{D}(\simplex{n})}\lessdot\simplex{n+1} \\[3pt]
  \simplex{n}\lessdot\simplex{n+1} \\[3pt]
  \singleton{\simplex{n}}\nlessdot\simplex{n} \\[3pt]
  \funct{\\lambda_n}=\nfunct{\pi_2}(\nfunct{\lambda_n}) \\[3pt]
  \funct{\\lambda_n}\lessdot\simplex{n+1}
\end{gathered}
\end{equation}

Again recalling the pivot projection, theorem \ref{thm:pivotprojection},
$\nfunct{\lambda}$, reduces to the functor,
$\funct{\lambda}$, embeded into next iterations,
$\funct{\lambda}$
The diagram functor, $\ofunct{\mathsf{D}}$, acts as a monomorphic inclusion
relation eq. \ref{eq:diagraminclusion} from eq. \ref{eq:allsimplex}.

\begin{equation}\label{eq:diagraminclusion}
\ofunct{\mathsf{D}}=\ofunct{\lessdot}
\end{equation}

\begin{equation}\label{eq:conesimplexnatural}
\begin{tikzpicture}
       [
            > = stealth, % arrow head style
            shorten > = 1pt, % don't touch arrow head to node
            auto,
%            node distance = 3cm, % distance between nodes
            semithick % line style
%            font=\tiny
       ]
\tikzstyle{every node}=[font=\smaller=3]
\draw [dashed] (-.9,0)
        ellipse (2.2 and .6) node[]
                    at (-2.6,.7) {$\simplex{n}$};
\draw [dashed] (3.1,.1)
        ellipse (.7 and 2.5) node[]
                    at (4,-2.1) {$\simplex{n+1}$};
\node[] (X1) at (-2.2,0) {$\simplex{0}$};
\node[] (X2) at (.4,0) {$\simplex{n}$};
\node[above right= 1 and 4.5 of X1] (Z1) {$\mathsf{D}(\simplex{0})$};
\node[right= 4.5 of X1] (Z2) {$\mathsf{D}(\simplex{n}})$};
\node[below right= .9 and 4.5 of X1] (Zz) {$\catN{1}_{\simplex{n}}$};
\path[--,dotted,gray] (X1) edge node[above] (DN) {} (X2);
\path[->,bend left] (X1) edge node[above] (D1) {$\obk{d}_{\simplex{0}}$} (Z1);
\path[->,bend left] (X2) edge node[above] (D2) {$\obk{d}_{\simplex{n}}$} (Z2);
\path[--,bend left=20,dotted,gray] (D1) edge node[] {} (D2);
\path[->,bend right] (X1) edge node[below] (B1) {$\obk{u}_{\simplex{0}}$} (Zz);
\path[->,bend right] (X2) edge node[below] (B2) {$\obk{u}_{\simplex{n}}$} (Zz);
\path[--,bend left=20,dotted,gray] (B1) edge node[] {} (B2);
\path[--,dotted,gray]
      (Z1) edge node[xshift=.5ex,yshift=-1ex,fill=white] {} (Z2);
\path[double,->,bend left=55] ([xshift=-2ex,yshift=1ex]B1.north)
      edge[double]
      node[below left] {$\lambda_{\simplex{0}}$}
      ([xshift=-2ex,yshift=-.5ex]D1.south east);
\path[double,->,bend left=55] ([xshift=-1ex,yshift=0ex]B2.north east)
      edge[double]
      node[below,right] {$\lambda_{\simplex{n}}$}
      ([xshift=1ex,yshift=-.5ex]D2.south east);
\end{tikzpicture}
\end{equation}

The constant functor of the empty domain category,
$\simplex{0}$, is a terminal category in, the category, $\simplex{1}$.
The cone transform

The category of all sets, $\setcat$, embraces categories with an
ordinal characteristic. Potentially the entirety of the
category of all sets, $\setcat$, resonates the formalism of Cantor
to develop all set cardenalities.
The finite sets establish an equivalence with the category of
all finite sets, $\fincat$. This section develops a category with countable
objects, $\simplexnn$, is a limit category of finite categories,
$\simplex{n}$.

The extent of set theory as an aspect of category theory
embraces and extends the seminal Von Neumann development of
ordinals from set constructs.
The robust development of ordinal representation with categories
attends an intuitive hypothesis of objects and arrow mappings.
Allegorically, a natural number object, $\simplexnn$,
actually a category, exists as an ordinal construct and reifies
underlying ordinal substructure of more general classes.
Likewise the natural number object consists of finite subcategories, $n$.
The simplest subcategory is the initial object, $\catN{0}$,
def. \ref{def:initial}.

As in set theory the entity of the initial or trivial category
derives existentially from nothing.
As such the initial category, $\catN{0}$, def. \ref{def:initial},
consists of no objects or arrows.
In reference to a set the forgetful functor renders the initial
category as an empty set, a partial qualification as a member of the
small category objects, $\smallcatobj$.

\begin{equation*}
  \ffunct:\,\catN{0}\rightarrow\varnothing
\end{equation*}

As an existential manifestation, the initial category similary
upholds the existential declaraton of any category or object,
eq. \ref{eq:existentialfunct}.

\begin{equation}\label{eq:existentialfunct}
  \mapaob{\catN{0}}{\exists}{\parsecat{C}}
\end{equation}

The dual of the initial category alternately declares the
terminal category, $\catN{1}$, def. \ref{def:terminal}.
The terminal category manifests distinct characteristics
extant from the initial category with an associated
internal object with corresponding identity arrow.
Essentially the terminal category complements the
poverty of constituents in the initial category. 
Notationally the dual relationship of the initial and terminal
category expresses as $\catN{0}=\catN{1}^*$ or $\catN{0}^*=\catN{1}$.
By definition the terminal category acts as a codomain object of a
subcollection of arrows for all objects of a category.
As such, the existence of
the terminal category complements the initial category
by pretext of a univeraal functor, $\funct{\forall}$,
mapping all objects of a category to a codomain terminal functor.

The terminal category is a prototypical model of a
general singleton category minimally consisting of one
object and one arrow.

Qualifying any category $\parsecat{C}$ as an object of a category requires
the category to be distinguished with a unique identity functor:

\begin{equation}\label{eq:categoryid}
  \mapaob{\parsecat{C}}{\oper{id}_{\parsecat{C}}}{\parsecat{C}}
\end{equation}

Equivalently the initial category acts as the
domain for the declaration of singletons from members of a codomain
object, genrally an $n-category$, fig. \ref{eq:singletoncat}.

\begin{equation}\label{eq:categoryid}\label{eq:singletoncat}
  \mapaob{\catN{1}}{\obk{c}}{\parsecat{D}}
\end{equation}

For a general example, the functor, $\funct{c}$, maps the domain, $\catN{1}$,
to a subcategory, $\csub{\parsecat{C}}{\parsecat{D}}$.
The subcategory, $\parsecat{C}$, is a singleton category
consisting of an arbitrary solitary object,
$\obk{c}\in\parsecat{D}$ with associated
identity arrows $\arrid{c}$ for each necessary category order.

A singleton construction generalizes to a UMP
functor $\umpclass_{\catN{1}}$ acting on the general collection of categories,
$\functcatcat$. For a category, $\parsecat{C}\in\functcatcat$,
as a domain and a singleton category codomain, $\singletoncat{C}$.
Explicitly, the singleton UMP subordinates a category, $\parsecat{C}$,
to an object with an identity functor, $\functid{C}$, eq. \ref{eq:categoryid}.

\begin{equation}\label{eq:generalsingleton}
  \mapaob{\catN{1}}{\parsecat{C}}{\singletoncat{C}}
\end{equation}

Interesting to the herein development is the mapping
of the initial category to the object with identity functor
of the singleton category, $\singleton{\catN{0}}$.

Another, extension by UMP of a general category, $\parsecat{C}$,
as a domain to the special singleton category, $\singletoncat{C}$, as
codomain. Denote this UMP as, $\umpclassp{\gtrdot}$ defines distinct
arrows with domain object in $\ccobj{C}$ and common codomain object
as the singular category, $\parsecat{C}\in\singletoncat{C}$.

\begin{equation}\label{eq:singletonump}
  \mapaob{\pazocal{C}}{\gtrdot}{\singletoncat{C}}
\end{equation}

Combining the functor collection, eq. \ref{eq:singletonump},
with the singleton codomain, eq. \ref{eq:generalsingleton},
yields the UMP, $\umpclassp{succ}$ defining a general category,
$\parsecat{C}$, successor, $\umpclasspc{succ}{C}$, eq. \ref{eq:successorcat}.

\begin{definition}{Successor UMP}\label{eq:successorcat}
\begin{equation*}\array{lll}
\wrpcat{\umpclasspc{succ}{C}}&=&\ccobj{C}\cup
        \wrpcat{\singletoncat{C}} \\[3pt]
\wrpfunct{\umpclasspc{succ}{C}}&=&\ccarr{C}\cup
        \wrpfunct{\singletoncat{C}}\cup \\[3pt]
        &&\{\funct{F}\mid\parsecat{O}=\functdom{F}\;\text{and}\;
        \parsecat{C}=\functcod{F}, \\[3pt]
        &&\hspace{30pt}\parsecat{O}\in\ccobj{C}\}
\end{array}
\end{equation*}
\end{definition}

A more practical application of the successor UMP, $\umpclassp{succ}$,
eq. \ref{eq:successorcat}. applies to a specific category of categories,
$\simplexnn$. The category, $\simplexnn$, conspicuously adopts the symbol,
$\Delta$, as a traditional reference to the collection of simplex graphs,
widely denoted as the coxeter group, $\mathbf{A_n}$. The simplex
category, $\simplex{n}\in\simplexnn$. consists of $n$ objects with
$\frac{1}{2}n(n+1)$ arrows. In contrast the traditional simplex graph
does not have identity arrows, rather consisting of simple vertices
instead of objects and edges connecting verticies
rather than the directed arrows of categories.
The comcept of simplex is the chosen mpdel to develop 
a category framework for the natural numbers, $\mathbb{N}$.

To begin the $0-simplex$ equivalates to the initial category, $\catN{0}$.
The $0-simplex$ equivalates as the $\simplex{0}$ category cosisting
of no objects or arrows.
A consistent ordinal sequence of categories derived from the initial
category, $\simplex{0}$, by recursive application of the UMP,
$\umpclassp{succ}$. The ordinal categories are denoted as
$\simplex{n}$. Identity arrows for each object of the category,
$\simplex{n}$, are assumed and specified, eq. \ref{eq:categoryid}.
The initial category is denoted as, $\simplex{0}=\catN{0}$.
A functor mapping from the initial category, $\simplex{0}$ to
the ordinal one category, $\simplex{1}$, is specified by, eq.
\ref{eq:generalsingleton}. 

\begin{equation}\label{eq:initialsingleton}
\array{ll}
  &\mapaob{\simplex{0}}{\oper{succ}}{\singleton{\simplex{0}}} \\[3pt]
\text{where}&\simplex{1}\;=\;\singleton{\simplex{0}}
\end{array}
\end{equation}

Continuing the oridinal sequence further is partially satisfied by
using the singleton result, $\ref{eq:generalsingleton}$, in
a product with the input ordinal category:

\begin{equation}\label{eq:simplexobject}
  \mapaob{\simplex{n}}{\oper{succ}}{\simplex{n+1}}
\end{equation}

Obvious properties, eq. \ref{eq:simplexproperty},
derive from the structure imposed by the
successor UMP, $\umpclassp{succ}$, by definition \ref{eq:successorcat}.

\begin{equation}\label{eq:simplexproperty}
\array{ll}
 \simplex{n}&\lessdot\simplexnn\;\forall\, n\in\mathbb{N} \\[3pt]
 \simplex{m}&\lessdot\simplex{n}\;\forall\, m,\,n\in\mathbb{N}\;\text{and}\;
 m\leq n
\end{array}\end{equation}

The monad, $\umpclassp{succ}$, maps the
domain category, $\simplex{n}$, to a category, $\simplex{n+1}$.
In elementary fashion the successor monad, $\umpclassp{succ}$,
maps the inital category, $\catN{0}$, to the terminal category, $\catN{1}$.
The universal singleton map demonstates the embedding necessary to
begin:

Ad infinitum the process
generates a category, $\simplexnn$, with an object
cardinality of the natural numbers, $\mathbb{N}$,
fig. \ref{fig:naturalnumbercat}.

\begin{equation*}
  \mapaob{\simplexnn}{\obk{succ}}{\simplexnn}
\end{equation*}

\begin{figure}
     \begin{tikzpicture}[
            > = stealth, % arrow head style
            shorten > = 1pt, % don't touch arrow head to node
            auto,
            node distance = 3cm, % distance between nodes
            semithick % line style
        ]

        \node[] (1) {$\catN{1}$};
        \node[] (N) [right of=0] {$\simplexnn$};

        \path[->] (1) edge node[above] {$\simplex{0}$} (N);
        \path[->] (N) edge [reflexive right]
                      node[anchor=center,midway,right] {$\oper{succ}$} (N);        
       \end{tikzpicture}
       \caption{Ordinal collection, note that arrows emerging from terminal
       object denote constants}\label{fig:naturalnumbercat}
\end{figure}

Transforming the natural number category objects, $\simplexnn$,
with the forgetful functor yields a set representation
of the natural numbers as defined by Von Neumann.

\begin{equation*}
  \ffunct_{,1}:\,\simplexnn\rightarrow\mathbb{N},
\end{equation*}

Finite number categories relative to actual
arrow construction develops abstractly thus far.
As categories the assingment of arrows between objects
requires careful attention. Apart from the requisite identity
arrows, a simple construct to follow
is that of the $n-simplex$ category representation for each
natural number category, $\simplexnn$. In this construct
each of the $n$ distinct objects of $\simplex{n}$ are domains
of new arrows to the $n+1^{\text{st}}$ object. Choose the $n+1^{st}$
object the category $\simplex{n+1}$.




To begin a construct to count objects choose the terminal category, $\catN{1}$,
as a diagram domain with a cone to define an embedded category, $\pazocal{Z}$.
The net result determines a category, $\pazocal{Z}$, consisting of two objects.
Ad infinitum this process continues to continues determine categories,
with any countable number of objects.

Now consider a diagram domain, $\catN{2}$, consisting of
two objects, $\obk{a}$ and $\obk{b}$, embedded in the codomain category,
$\pazocal{Z}$. The limit of this embedding determins the product,
$\obk{a}\times\obk{b}$, of objects, $\obk{a}$ and $\obk{b}$.



In particular consider the diagram domain as simple the category,
$\catN{2}$, a category with two objects.

This section begins by outlining the concept of an equalizer
that shapes the idea of a category characterized by monomorphic arrows.

An equalizer extends on diagram \ref{eq:equalizercollection}
with the property, $\arr{f}\circ\arr{e^{\prime}}=\arr{g}\circ\arr{e^{\prime}}$:

\begin{figure}
\begin{tikzcd}[row sep=2em, column sep=2em,
execute at end picture={
            \node[] at (-1.6,1) {$\pazocal{P}$};
            \node[ellipse,draw,dashed,inner sep=1pt,
            fit={(tikz@f@1-1-1) (tikz@f@1-2-1)}]{};}]
\obk{z} \arrow[r, "\obk{e}"] &
\obk{a} \arrow[r, shift left, "\obk{f}"] \arrow[r, shift right, "\obk{g}"'] &
\obk{b} \\
\obk{z^{\prime}}  \arrow[u, hook, dashed, "\obk{k^{\prime}}"]
\arrow[ur, dashed, "\obk{e^{\prime}}"']
\end{tikzcd}
\caption{}\label{eq:equalizer}
\end{figure}

\begin{equation}\label{eq:equalizercollection}
\begin{tikzcd}[row sep=2em, column sep=2em]
\obk{z^{\prime}} \arrow[r, "\obk{k^{\prime}}"] &
\obk{a} \arrow[r, shift left, "\obk{f}"] \arrow[r, shift right, "\obk{g}"'] &
\obk{b}
\end{tikzcd}
\end{equation}

Extending the diagram, \ref{eq:equalizercollection}, to
figure, \ref{eq:equalizer}, develops a more general construct of a
category, $\parsecat{P}$, with a terminal object, $\obk{z}$,
as the codomain of a collection arrows, $\arr{k^{\prime}}$,
each with a unique domain object, $\obk{z^{\prime}}\in\ccobj{P}$,

\begin{definition}{Equalizer},
  is an arrow, $\arr{e}$, identifying an equivalence subdomain for
  a pair of arrows, $\apair{f}{g}$, sharing
  the same domain and codomain objects, $\obk{a}$ and $\obk{b}$ respectively.
  \begin{equation*}
     \begin{gathered}
     \mapaob{z}{e}{a} \\
     \arr{e}(z)\lessdot\obk{a}=\arrdom{\fpair{f}{g}} \\
     \arr{f}\circ\arr{e}=\arr{g}\circ\arr{e}
    \end{gathered}
  \end{equation*}
  The equalizer is further a limit of a category $\parsecat{P}$
  denoted in fig. \ref{eq:equalizer}
  \begin{equation*}
     \begin{gathered}
     \forall\,\obk{z^{\prime}}\in\ccobj{P}\quad
     !\exists\arr{k^{\prime}}\in\ccarr{P} \\
     \obk{z^{\prime}}=\arrdom{k^{\prime}}\;\text{and}\;
     \obk{z}=\arrcod{k^{\prime}} \\
     \text{where}\;\arr{e^{\prime}}=\arr{e}\circ\arr{k^{\prime}}, \\
     \text{and}\;\arr{f}\circ\arr{e^{\prime}}=\arr{g}\circ\arr{e^{\prime}}
    \end{gathered}
  \end{equation*}
\end{definition}

The equalizer category, $\parsecat{P}$, extends to a hierachical construction
with the concept of a cone. The cone consists of a subcategory,
$\csub{X}{P}$ relative to objects $\obk{z}$, of another collection,
$\parsecat{Z}$. 

Equalizer category, $\parsecat{P}$, of figure \ref{eq:equalizer},
has a terminal object, $\obk{z}$, with unique arrows,
$\arr{k^{\prime}}\in\ccarr{P}$, directed from domain objects in,
$\ccobj{P}$ to codomain, $\obk{z}$.
The arrows of the collection, $\ccarr{P}$ are exclusively monic arrows.
Categories exclusively characterized by monic arrows are and a terminal
object are preorders. A more general preorder consists of monic arrows
between the objects of the collection $\ccobj{P}$. An object pair
mutually associated by dual monic arrows are isomorphic. 

\subsubsection{Subobject Category}

\begin{definition}{Subobject UMP, $\parsecat{Sub}$}, \label{def:subobject}
  acts on slice categories, $\parsecat{C/c}$. The subobject
  category contains a terminal object $\obk{c}$
  \begin{equation*}
    \begin{array}{llll}
    \wrpobj{\subcat{C/c}}&=\{\arrdom{r}&\mid&\arr{r}\in\catobj{C/c}\} \\[3pt]
    \wrparr{\subcat{C/c}}&=\{\arr{r}&\mid&!\exists\,\arr{k^{\prime}},\,
                          \arr{k^{\prime}}=\arrid{o},\,\obk{o}\in\ccobj{P}\\[3pt]
      &\text{or}&&\arr{e^{\prime}}=\arr{e}\circ\arr{k^{\prime}}, \\[3pt]
      &&&\arrcod{e}=\arrcod{e^{\prime}}=\obk{a},\, \\[3pt]
      &&&\arrcod{k^{\prime}}=\arrdom{e}, \\[3pt]
      &&&\arrdom{k^{\prime}}=\arrdom{e^{\prime}}\}
  \end{array}
  \end{equation*}
  Given a slice category, $\parsecat{C/c}$, denote the subcategory mapping as,
  $\subcat{C/c}\lessdot\parsecat{C/c}$, a subcategory of the slice category,
  $\parsecat{C/c}$, relative to category,
  $\parsecat{C}$, over object, $\obk{c}$.
  The object conllection $\wrparr{\subcat{C/c}}$ consists of arrows
  with a domain object subcollection from $\ccobj{C}$.
  \begin{equation*}
  \begin{array}{lll}
    \wrpaobj{\subcat{C/c}}&=&\{\arr{r}\mid\arrcod{r}=\obk{c}\}\;
    \obk{c}\in\parsecat{c} \\[3pt]
           &&\{\arrdom{r}\mid\arr{r}\in\wrpobj{\subcat{C/c}}
  \end{array}
  \end{equation*}
  The subobject
  category arrow collection exclusively consists of monomorphic
  arrows. Each nontrivial collection,
  $\wrparr{\subcat{C/c}_{\rightarrow,}}\cpair{a}{b}$,
  is a singleton collection of one monomorphic arrow, $\lessdot$,
  for each distinct domain/codomain object pair, $\cpair{a}{b}\in\ccpair{C}$.
\end{definition}

Monomorphic properties of arrows are established with equivalence
of certain communicable diagrams. Preorders are shown to be generalizations
of such diagrams.

The slice category provides a starting concept to establish
the structure of cocones and eventually the subobject category.
The object collection, $\catobj{C/c}$, of a slice category,
$\parsecat{C}$, consists of arrows with a common codomain object, $\obk{c}$,
A collection of arrows from, $\catobj{C/c}$, can be further limited
to monomorphisms, the domain objects of which form an object collection
$\ccobj{P}$, including the terminal object, $\obk{c}$.

A subobject category results from limiting a slice category to
monomorphic arrows. The essential concept exploits the monomorphic
property of the subcategory arrow, $\lessdot$.

Essentially, choosing a terminal object, $\obk{c}\in\parsecat{C}$, the
subobject category, $\subcat{C/c}$, establishes all subcollection
relations relative to that object, $\obk{c}$ in the context of the
category, $\parsecat{C}$. In a broader context given a subcollection,
$\obk{b}\lessdot\obk{c}$, then $\subcat{C/b}\lessdot\subcat{C/c}$.
Implicitly, the terminal object of a the preorder, $\subcat{C/c}$, is $\obk{c}$.

A subobject category is alternately named a preorder.
Functors indicate the existence the embedding of a preorder in
another preorder, such as,  $\subcat{C/b}\lessdot\subcat{C/c}$.
The a Galois connection depends more closely related adjoint preorders
$\adj{\parsecat{P}}{\parsecat{Q}}$
with adjoint functors, $\adj{\funct{U}}{\funct{F}}$:

\begin{definition}{Galois Connection}, relates
a pair of preorders, $\adj{\parsecat{P}}{\parsecat{Q}}$,
with adjoint functors, $\adj{\funct{U}}{\funct{F}}$:
\begin{equation}
\parsecat{P}\,
\arraycolsep=1.4pt\def\arraystretch{.5}
\begin{array}{l}
\xleftarrow{\quad\obk{U}\quad} \\
\xrightarrow[\quad\obk{F}\quad]{}
\end{array}\parsecat{Q}\qquad\adj{\funct{U}}\,{\funct{F}}
\end{equation}
\end{definition}

Adjunct preorders conform to an isomorphic relation of order
as denoted by the ratio: 

\begin{equation}
\frac{\functV{F}{a}\lessdot\obk{x}}
{\obk{a}\lessdot\functV{U}{x}}
\end{equation}

A preorder establishes another structure of objects relative to the terminal
object $\obk{x}$ of the preorder, $\parsecat{P}$. 

A cone supports a diagram limit that complements preorder categories.
Consider a functor, $\funct{F}$, that embeds a diagram, $\parsecat{D}$,
into a category, $\parsecat{C}$.

\begin{definition}{Cone, $\cpair{x}{\mu}$},\label{def:cone}
consists of a natural transform, $\nfunct{\mu}$,
a functor, $\funct{F}=\nfunctcod{\mu}$
with categories, $\parsecat{D}=\functdom{F}$ and $\parsecat{D}=\functdom{F}$
with an object, $\obk{x}\in\parsecat{C}$,
$\mapaob{\catN{1}}{\obk{x}}{\parsecat{C}}$,
$\singletoncat{x}\lessdot\parsecat{C}$,
where $\functscr{F}_{\oper{id}_{\singletoncat{x}}}=\nfunctdom{\mu}$.
$\forall\obk{d}\in\ccobj{D}$ there exists a mapping
$\mapaob{\obk{c}}{\mu_{\obk{d}}}{\functV{F}{d}}$.
\end{definition}

The unique domains of preorder arrows, $\arr{r}\in\parsecat{C/c}$,
$\arrdom{r}$, provide a collection of objects f

The existential ablility to selectively identify an object from a category
with each sample independent of others supports the development of
new constructs in category theory with eventual formulation of the
axiom of determinancy.
To begin two objects, $\arr{f}$ and $\arr{g}$, are identified as
independent samples from a preorder, $\parsecat{P}$ with terminal
object, $\arrid{c}$, the identity arrow of $\obk{c}$.
Denote, $\obk{a}$ and $\obk{b}$, as the domains of arrows, $\arr{f}$ and
$\arr{g}$, respectively.
Independence is upheald by the application of arrows,
$\arr{f}$ and $\arr{g}$, enforciing the sample process.

The concept of independent object samples provisions
the dual constructs of intersection union of $\obk{a}$ and $\obk{b}$.
A pulback is a construct acting on this scenario.

\begin{definition}{Pullback}
  is a domain object, $\obk{z}$, 
  is a construct derived from a pair of arrows, denote $\apair{f}{g}$,
  relative to domain object, $\obk{z}$,
  with an arrow pair $\fpair{z_1}{z_2}$
\end{definition}


Independence of samples is discriminated by the pair $\cpair{a}{b}$.
Without set theory the concept
of independence supports the discrimination of,
$\arr{f}$ and $\arr{g}$.

A pullback and an equalizer act on objects, $\obk{a}$ and $\obk{b}$
to construct a product 
figure \ref{fig:universalproduct}.
A pullback consists of a domain object, $\obk{p}$, with
projection arrows, $\arr{g_p}$ and  $\arr{f_p}$, to objects,
$\obk{a}$ and $\obk{b}$, respectively,
To establish surjectivity an equalizer emmanating as a contained
object $\obj{z}$ of $\obk{p}$, $\obk{z}\lessdot\obk{p}$, relative
to arrow, $\arr{e_{zp}}$ and projections, $\arr{z_1}$ and $\arr{z_2}$, 
to objects, $\obk{a}$ and $\obk{b}$, respectively.

\begin{equation*}
\begin{array}{rll}
\obk{z}&\;\lessdot&\obk{p} \\[3pt]
\arr{z_1}=\arr{g_p}\circ\arr{e_{zp}}&\text{and}&
\arr{z_2}=\arr{f_p}\circ\arr{e_{zp}} \\[3pt]
\arr{z_1}(\obk{z})\lessdot\obk{a}&\text{and}&
\arr{z_2}(\obk{z})\lessdot\obk{b} \\[3pt]
\obk{a}\lessdot\obk{c}&\text{and}&\obk{b}\lessdot{c}
\end{array}
\end{equation*}

Since $\obk{z}$ is an arbitrary subobject of $\obk{p}$
a preorder category, $\parsecat{Y}$, consists of category objects,
$\obk{z}$, with a terminal object, $\obk{p}$ relative to the
collection of arrows, $\arr{e_{zp}}$. The preorder arrow
is constructed as a pair of arrows to $\obk{p}$ as $\apair{z_1}{z_2}$.
Projecting from, objects of $\parsecat{Y}$, are arrows to
objects, $\obk{a}$ and $\obk{b}$, respectively.

The equilizer is constructed with arrow,
$\arr{e_{zp}}=\apair{z_1}{z_2}$,
implies that the terminal object, $\obk{p}$,
is in fact the the independent intersection of objects,
$\obk{a}$ and $\obk{b}$, alternately denoted as a product,
$\obk{p}=\cpair{a}{b}$, with projection arrows,
$\arr{\pi_1}=\arr{g_p}$
and $\arr{\pi_1}=\arr{g_p}$ projecting to objects,
$\obk{a}$ and $\obk{b}$, respectively. The sample independence of 
, $\obk{a}$ and $\obk{b}$, upholds the that the object $\obk{p}$
is an intersection consistent with the identities rather than the
constituents of, $\obk{a}$ and $\obk{b}$.

\begin{figure}
     \begin{tikzpicture}
       [
            > = stealth, % arrow head style
            shorten > = 1pt, % don't touch arrow head to node
            auto,
            node distance = 3cm, % distance between nodes
            semithick % line style
        ]

        \draw [thin,gray,dashed] (0,-1.7)
        ellipse (.8cm and 2.1cm) node[text=gray]
                    at (.76,-.16) {$\pazocal{P}$};
        \node[] (z) {$\obk{z}$};
        \node[] (p) [below of=P] {$\obk{p}$};
        \node[] (a) [below left of=p] {$\obk{a}$};
        \node[] (b) [below right of=p] {$\obk{b}$};
        \node[] (c) [below of=p] {$\obk{c}$};
        
        \path[->,dashed] (z) edge
        node[xshift=-1.5em,yshift=-2em,fill=white] {$\obk{e}_{zp}$} (p);
        \path[->] (z) edge node[above left] {$\obk{z_1}$} (a);
        \path[->] (z) edge node[above right] {$\obk{z_2}$} (b);
        \path[->] (p) edge node[below right] {$\obk{g_p}$} (a);
        \path[->] (p) edge node[below left] {$\obk{f_p}$} (b);
        \path[->] (a) edge node[below left] {$\obk{f}$} (c);
        \path[->] (b) edge node[below right] {$\obk{g}$} (c);
    \end{tikzpicture}
      \caption{dashed arrow denotes the inference of an initial object,
        $\obk{a}\times\obk{b}$, from category,
        $\pazocal{Y}$ with objects $\obk{z}$
        and arrows $\arr{e_{zp}}=\apair{z_1}{z_2}$ with 
        $\arrcod{e_{zp}}=\obk{a}\times\obk{b}$ and
        $\arrdom{e_{zp}}=\obk{z}$.}
        \label{fig:universalproduct}
\end{figure}

The distinct functor mapping of the triple,

$(\obk{a}\times\obk{b},\,\arr{\pi_1},\,\arr{\pi_2})$

reflects the projection behavior of a pair or $2-tuple$.
Subsequently, internal to the product category, objects are constructed with
the object pairs:

\begin{definition}{Pair Projection}\label{def:pair},
  $\cpair{a}{b}$,
  $\obk{a}$, $\obk{b}$ are objects, $\arr{\pi_1}$. $\arr{\pi_2}$, are arrows:
\begin{equation*}
    \obk{a}=\arr{\pi_1}\cpair{a}{b}\quad\text{and}
    \quad\obk{b}=\arr{\pi_2}\cpair{a}{b}.
\end{equation*}
\end{definition}

Recalling the pair definition from $n-tuple$ functional designations,
$\arr{\pi_1}$ and $\arr{\pi_2}$,
are alternately replaced by, $\oper{fst}$ and $\oper{snd}$ acting on pair.

\begin{equation*}
  \obk{a}=\oper{fst}\cpair{a}{b}\quad\text{and}
  \quad\obk{b}=\oper{snd}\cpair{a}{b}
\end{equation*}

Applying projection functors to the commuting
arrow collection of, $\catarr{Y}$:

\begin{center}
  $\arr{e_{zp}}=\apair{z_1}{z_2}$, \\[3pt]
  $\arr{z_1}=\arr{\g_p}\circ\arr{e_{zp}}\quad$ and
  $\quad\arr{z_2}=\arr{\f_p}\circ\funct{e_{zp}}$ \\[3pt]
  $\forall\quad\obk{z}\in\catobj{Y}$
\end{center}
\end{definition}

Inference of the $n-tuple$, def. \ref{def:tuple}, provides
closure to the pairwise construction of the product category:

\begin{definition}{Product Category},\label{def:product}
  $\parsecat{C}\times\parsecat{D}$ is is a construction
  relative to two categories, $\parsecat{C}$ and $\parsecat{D}$
\begin{itemize}
\item$\wrpobj{\parsecat{C}\times\parsecat{D}}=
  \cpair{a}{b}\mid\,
  \obk{a}\in\catobj{C}\quad\text{and}\quad\obk{b}\in\catobj{D}\}$
  \item$\wrparr{\parsecat{C}\times\parsecat{D}}=\{(\arr{f},\arr{h})\mid
    \arr{f}\in\catarr{C}\,\text{and}\,\arr{h}\in\catarr{D}\}$
  \begin{itemize}
  \item\textbf{(Domain)} \\
    $\qquad\qquad\qquad\arrdom{\fpair{f}{h}}=\cpair{\arrdom{f}}{\arrdom{g}}$
  \item\textbf{(Codomain)} $\arrcod{\fpair{f}{h}}=
    \cpair{\arrcod{f}}{\arrcod{g}}$
  \item\textbf{(Composition)} \\[3pt]
    $(\arr{f},\arr{h})\circ(\arr{f^\prime},
    \arr{h^\prime})=(\arr{f\circ f^\prime},\arr{h\circ h^\prime})$
  \item$\arrid{(\obk{a},\obk{b})}=(\arrid{a},\arrid{b})$
    $\forall\,(\obk{a},\obk{b})\in\wrpobj{\parsecat{C}\times\parsecat{D}}\quad$ \\[3pt]
  where $\arrid{a}\in\catarr{C}\quad\text{and}\quad\arrid{b}\in\catarr{D}$
  \end{itemize}
\end{itemize}
\end{definition}

The product, $\prod$, of categories is an operation on an ordered
$n-tuple$ of categories.
Recursively extending the product construction from $n-tuple$
to $n+1-tuple$ defines a general product on a larger $tuple$.
An $n-tuple$ of ordinals from $1$ to $n$ is denoted as $(n)$.

\begin{align}\label{eq:n-product}
(\prod_{i\in (n)} \parsecat{C}_i,\,\funct{\pi_1},\cdots,\,\funct{\pi_n})
\end{align}

The parwise construction of objects and arrows between
constituent categories of the product. In particular
the product of the zero category with any category
is the zero category:

\begin{equation*}
  \catN{0}\times\parsecat{C}=\parsecat{C}\times\catN{0}=\catN{0}
\end{equation*}

The dual of product, $\times$, is coproduct, $+$.

The coproduct, $\parsecat{C}+\parsecat{D}$, is the initial
object of $\parsecat{Y}^{op}$.

The dual of the projection functors of the product is the
injection functors, $\obk{i_1}$ and $\obk{i_2}$ of the coproduct.
The dual of the terminal is the initial limit object of,
$\parsecat{Y}^{op}$ is $\parsecat{C}+\parsecat{D}$. 

\begin{figure}
     \begin{tikzpicture}[
            > = stealth, % arrow head style
            shorten > = 1pt, % don't touch arrow head to node
            auto,
            node distance = 3cm, % distance between nodes
            semithick % line style
        ]

        \draw [thin,gray,dashed] (0,1.7) ellipse (.8cm and 2.1cm)
                    node[text=gray] at (.8,0) {$\parsecat{Y}$};
        \node[] (W) {$\parsecat{W}$};
        \node[] (P) [above of=W] {$\parsecat{C}+\parsecat{D}$};
        \node[] (C) [above left of=P] {$\parsecat{C}$};
        \node[] (D) [above right of=P] {$\parsecat{D}$};
        
        \path[<-,dashed] (W) edge
              node[xshift=1.3em,yshift=1em,fill=white]
                                              {$\funct{m_W}$} (P);
        \path[<-] (W) edge node[below left] {$\funct{G_W}$} (C);
        \path[<-] (W) edge node[below right] {$\funct{H_W}$} (D);
        \path[<-] (P) edge node[above right] {$\funct{i_1}$} (C);
        \path[<-] (P) edge node[above left] {$\funct{i_2}$} (D);
    \end{tikzpicture}
      \caption{dashed arrow denotes the inference of an initial object,
        $\pazocal{C}+\pazocal{D}$, from category,
        $\pazocal{Y}$ with objects $\pazocal{W}$
        and arrows $\funct{m_W}=[\funct{G_W},\funct{H_W}]$ with 
        $\functdom{m_w}=\pazocal{C}+\pazocal{D}$ and
        $\functcod{m_w}=\pazocal{W}$.}
        \label{fig:universalcoproduct}
\end{figure}

The coproduct, $\coprod$, of categories is an operation on a catagory bag.
A bag, $[\cdots]$, is the opposite of an $n-tuple$,
an unordered collection of categories, $\parsecat{C}_i$,
that admits duplicates. A bag of ordinals from the set
$\{1,\cdots,\,n\}$ is denoted as $[n]$. The
$n-$coproduct dual of the $n-$product, \ref{eq:n-product}:

\begin{align}\label{eq:n-coproduct}
  (\coprod_{i\in [n]} \parsecat{C}_i,\,
  [\funct{\oper{i}_1},\cdots,\,\funct{\oper{i}_n}])
\end{align}

Coproduct acts to combine constituent categories however
unlike product there is no construction of arrows between
objects of constituent categories. The net affect of
the coproduct of the zero, $\catN{0}$, category
and any other category is the latter category:

\begin{equation*}
  \catN{0}+\parsecat{C}=\parsecat{C}+\catN{0}=\parsecat{C}
\end{equation*}

The dual nature of the coproduct also reveals
the dual of an $n-tuple$ to be a commutative
collection of objects relative to a disjoint union.
Details of this require analysis of the product
and coproduct with sets.

Pair construction, def. \ref{def:pair}, derived from
category product, def. \ref{def:product}, provides
a basis to construct other interesting categories.

Collections with set properties admit
aspects of analysis that are impossible for
general collections. The Yoneda lemma of category
theory provides an approach to analyze
aspects of abstract categories with
categories that embrace the limits and regiarity
of sets. In particular, The Yoneda lemma
determines the accessibility of abstact
catetegories to algorithmic analysis.

\section{Sets}

Properties and relations of categories are transformed and
analyzed at an abstract or meta-level, as in prior sections.
Set characterics extends the meta-analysis and construction of
categoriies with greater qualitative and quantitative behavior.
Admiting set behavior into category theory endows quantitative
measurability and structure to objects and arrow behavior
beyond general or universal behavior.

Integrating set behavor into category theory imbues
greater structure and analysis capabilities.
In particular, as a collection admits the behavior of a proper class,
familiar to Von Neumann-Bernays-G\"{o}del set theory,
then the discreat behavior of concrete sets from
Zermelo-Frankel set theory.
In a broader sense the proper class is specified
by collective properties of constituent members without
distinction of specific elements. Continuing to sets
requires that the members of the collection are
enumerable or associated with a cardinal size, in fact
sets can be distinguished from one another strictly by
distinct members. The earlier definition of ordinals,
eq. \ref{def:ordinals}, and $n-tuple$, def. \ref{def:tuple},
introduced elementary aspects of cardinality.
A broader definition of cardinality is used in this
section. The size, sometimes infinite,
of a set is a cardinality
assigned to a set with unitary operator, $\kappa$,
hence the cardinality of a set, $S$, is $\scard{S}$.

Several texts provide a preamble to develop
set operations. Notation and peripherial concepts
not detailed herein are found in
Hungerford's algebra text, \cite{hungerford1974}.
For instance topics relied on in the text are,
\cite{hungerford1974}, cartesian product,
$A^{n+1}=A^n\times A$, $n\in\mathbb{N}$
and set theory.
Axioms of choice and order, \cite{hungerford1974},
combined with the Cantor's development of
cardinal bases, form the real number set,
$\mathbb{R}$. The set theory development in
the text of Barr and Wells, \cite{barrwells1990}, provides
useful development of category theory
from principles of set theory and graphs.
Some of the Other areas
of adherance are model theory, \cite{hodges1993},
and category theory, \cite{awodey2010}.
Certainly the study of mathematics embraces several
language theories, \cite{hodges1993},
or disciplines. In particular
the theory of algebra associates well with
category theory, \cite{awodey2010}. A relationship that
is facilitated in the text.

\subsection{Antinomies}

Antinomies is a term expounded by Zermelo to clasify
contradictions of set theory and logic originally discovered
by Cantor and Russell.

Cantor extended the na\"{i}ve concept of a finite sets to
determine a countable set of exceptional cardinalities
bounded below by that of natural numbers, $\aleph_0=\scard{\mathbb{N}}$
and real numbers, $\mathfrak{c}=2^{\aleph_0}=\scard{\mathbb{R}}$.

\begin{equation}
  \beth_0=\aleph_0\,\,\text{and}\,\,\,\beth_{n+1}=2^{\beth_n}
\end{equation}

In measure theory, Cantor's discovery that set
cardinalities subordinate to the real line have trivial measure
was soon negotiated by Hausdorff's discovery of fractional dimensions
to measure the recursive geometries of Cantor sets with limit integrals,
a precursor to the visual titilations of
Mandelbrot sets and fractals in computer graphics.

Essential to Cantor's sequence of cardinalities is the power set:

\begin{equation}\label{eq:pset}
  \pset{S}=\{A\mid\,A\lessdot S\}
\end{equation}

Fundamental to the proof of Cantor's eponymous sequence of cardinalities
is the imposibility of a function to map a set surjectively onto its power set:

\begin{theorem}{Cantor}\label{th:cantor}, a function,
  $f:\,S\rightarrow\pset{S}$,
  is not surjective. Henceforth:
  \begin{center}
    $f(S)\neq\pset{S}$
  \end{center}
\end{theorem}

\begin{proof},
  define a set, \\[3pt]
  \begin{center}
  $A=\{x\in S\mid x\notin f(x)\}\in\pset{S}$.
  \end{center}
  If $S=\varnothing$ then $f(S)\neq\pset{S}$, \\[3pt]
  $\Rightarrow\,S\neq\varnothing$ and
  $\varnothing\in f(S)$ otherwise $f(S)\neq\pset{S}$. \\[3pt]
  Hence $\exists\,a\in A$ and $f(a)=\varnothing$, \\[3pt]
  but, $\nexists\,b\in S$ such that $f(b)=A$, \\[3pt]
  therefore $A\notin f(S)$ and $f(S)\neq\pset{S}$ $\square$
\end{proof}

For any set, $S$, the cardinality is denoted as $\scard{S}$.
From theorem, \ref{th:cantor}, a strict inequality of cardinality
is implied:

\begin{equation}\label{eq:cantor}
  \scard{S}<\scard{\pset{S}}=2^{\scard{S}}
\end{equation}

The foundation of set theory established cardinalities and a basis
to advance measure theory with $\sigma-algebra$ and posets.
An assult of contradiction however maintained a threat to the symbiotic
establishment of set theory and logic as a foundation of
mathematics. Essentially a fundamental contradiction of terms
exists on the premise of a universal set of all sets.
Cantor's theorem formalized one contradiction since each power
set is not contained within its basis set ad infinitum without
completion. The logician Frege
subsequently volleyed a solution that quickly received dismissal
from the mathemetician and philosopher, Bertrand Russell,
\cite{russell1902}. Essentially, Russell, \cite{russell1902},
posed a contradiction from axiom for a set to be a member of itself:

\begin{equation}\label{eq:russel}
  R_A=\{x\in A: x\notin x\}
\end{equation}

Extending $R_A$ to the universal set established the seminal contradiction.
Hilbert stated in his famous 20\textsuperscript{th}
century address that a foundation of mathematics in
logic and set theory would be discovered.
Russell waxed philosophically
on the matter with the expectation that his distinguished protog\`{e},
Witgenstein, would prevail on the conundrum.
Ultimately in 1933, Kurt G\"{o}del,
proved the mutual exclusivity of completness and consistency in
logic for any axiomatized language, hence the imposibility of a solution.

The alternate approach embraces a strategey to
axiomatizes set theory to avoiding rather than confront
the paradoxes pursued by Cantor and Russell.
Zermelo extablished the most general theoretical approach
whereas Mac Lane established the most practical approach
conforming to the formation of topos theory. Mac Lane
developed category theory with a motive to navigate
solutions around ambiguities based on underying axioms.
The use of classes by Zermelo is an approach to initiate
discussion of collections by properties. classes with
cardinality properties would be sets otherwise
these could be broad universes. Category theory
easily admits the class abstraction which was
adopted in computer programming with
fuctional programming and more broadly
contested as an abstraction
for object oriented programning.

\subsection{Fixed Point}

The universality of self referential paradoxes due to fixed point
theory characterizes a variety of anomolies; set theory antinomies,
Cantor's theorem, Russell's paradox,
Tarski's non-definability of truth and G\"{o}del's first
incompleteness theorem. Self referential paradoxes characterize
these defects of logic as well as asserting the fixed-point
behavior of disparate topics of game theory and quantum spin.

Construction of the self referential category model proceeds as
displayed, fig. \ref{fig:fixedpoint}. Theorem \ref{thm:fixedpoint}
elucidates the detail of, fig. \ref{fig:fixedpoint}.

\begin{theorem}{Fixed Point Theorem}\label{thm:fixedpoint},
  given a cartesian closed category, $\parsecat{C}$, with objects,
  $\pazocal{T},\,\pazocal{Y}\in\ccobj{C}$ and pointwise surjective
  second order arrow, $\nfunct{\phi}$, of the collection
  $\snat\cpr{\ccid{T}}{\cpr{\ccid{T}}{\pazocal{Y}}}_{\functscr{N}}$,
  proscribes
  fixed points for all arrows $\funct{\alpha}$ of the collection
  $\homcat\cpair{\pazocal{Y}}{\pazocal{Y}}=\expab{\pazocal{Y}}{\ccid{T}}$.
\end{theorem}

Theorem \ref{thm:fixedpoint} embelishes Lawvere's fixed point theorem
from a greater adherance to category theory definitions over
set theory. The general fixed point theory requires the small
property of categories, however, theorem \ref{thm:fixedpoint},
employs natural transforms rather than ill posed set functions
from a domain set to a function space. Category theory requires mapping
from similarly ordered category types. In particular definitions in literature
apply ill posed mappings from an object collection to a functor collection.
Theorem \ref{thm:fixedpoint} employs the natural transform, $\nfunct{\phi}$,
a pointwise surjective function from a set of identity arrows, $\ccid{T}$,
to a set of functors, $\homcat\cpr{\ccid{T}}{\pazocal{Y}}$,
sharing the domain $\parsecat{T}$ and codomain $\parsecat{Y}$.
The small property of the collections assures
that set and function properties of surjectivity and pointwise apply.
Pointwise surjectivity assures that any member,
$\mapaob{\catN{1}}{\pbk{q}}{\nfunctcod{\phi}}$, of the codomain lifts from
$\mapaob{\catN{1}}{\pbk{p}}{\nfunctdom{\phi}}$, of the domain.
Pointwise however does not extend to limit points. An example of
pointwise surjectivity is the Fourier transform. The qualification
of epimorphism is more restrictive than pointwise surjective.

\begin{proof}\ref{thm:fixedpoint}
  Relative to figure, \ref{fig:fixedpoint}, extend the composite mapping
\begin{equation}
\mapaob{\ccid{T}}{\cohopfmult}{
  \mapaob{\ccid{T}\times\ccid{T}}{\langle\phi,\,\singleton{\ccid{T}}\rangle}{
    \mapaob{\expab{\pazocal{Y}}{\ccid{T}}\times\ccid{T}}{\oper{eval}}{
    \mapaob{\pazocal{Y}}{\alpha}{\pazocal{Y}}
} } }
\end{equation}
  Given $\alpha\in\homcat\cpair{\parsecat{Y}}{\parsecat{Y}}$, with
  a function, \\
  $\mapaob{\catN{1}}{\pbk{q}}{\nfunctcod{\phi}}=\expab{\pazocal{Y}}{\ccid{T}}$,
  
\end{proof}


\begin{figure}
     \begin{tikzpicture}[
            > = stealth, % arrow head style
            shorten > = 1pt, % don't touch arrow head to node
            auto,
            node distance = 2cm, % distance between nodes
            semithick % line style
        ]
        \node[] (YxT) {$\pazocal{Y}^{\ccid{T}}\times\ccid{T}$};
        \node[] (TxT) [below left of=YxT] {$\ccid{T}\times\ccid{T}$};
        \node[] (YY) [below right of=YxT] {$\pazocal{Y}$};
        \node[] (Y) [below of=YY] {$\pazocal{Y}$};
        \node[] (T) [below of=TxT] {$\ccid{T}$};
        
        \path[->] (TxT) edge
          node[above left]
          {$\langle\:\nfunct{\phi},\,\singleton{\ccid{T}}\rangle$} (YxT);
        \path[->] (YxT) edge node[above right] {$\oper{eval}$} (YY);
        \path[->] (T) edge node[below] {$\obk{g}$} (Y);
        \path[->] (T) edge node[left] {$\cohopfmult$} (TxT);
        \path[->] (YY) edge node[right] {$\alpha$} (Y);
    \end{tikzpicture}
      \caption{}
        \label{fig:fixedpoint}
\end{figure}

The concept of the fixed point commutative exposition of sets
and arrows depends of the definition of arrows, $\arr{\delta}$,
$\arr{\alpha}$, $\arr{f}$ and $\arr{g}$. The arrow, $\arr{\delta}$,
maps a domain set to a the diagonal pairs subset of $\obk{T}\times\obk{T}$.
The arrow, $\arr{f}$, characterizes a parameterized function
that parameterizes a collection of functions with the set $\obk{T}$,
$\mapaob{\obk{T}\times\obk{T}}{\obk{f}}{\obk{Y}}$ is isomorphic
with the mapping, $\mapaob{\obk{T}}{\obk{f}\cpair{-}{t}}{\obk{Y}^{\obk{T}}}$,
where $\obk{t}\in\obk{T}$. To find is a singular parameter,
$\obk{t}\in\obk{T}$, such that $\arr{g}=\arr{f}\right_{\obk{t}}$.

\subsection{Categories as Sets}

Prior sections focus on the properties and mappings of categories.
A large category, $\largecat$, supported the analysis of categories
with universal mapping classes, functors and the structure of
arrow collections on objects. The intoduction of set concepts
to category theory provides tools of cardinality for analysis
of discrete members, quantifiable collections and the locality or
neighbourhoods of members.

The universal mapping and construction developed in previous sections
extended the structure of categories. In contrast, this section seeks
definition for universal maps that reduce a, $0-category$, to a set
or a set with specific cardinality. Reduction of abstract categories
to sets supports a the use of a wide range of analysis tools and
alternate fields of mathematics. Even in the consideration of a
general category of objects or a functor the bounding restriant
of characteristic and behavior typically rely on set cardinality
despite the unboundend nature of an underlying class of members.
Denote a general UMP applied to reducing general categories
to sets as forgetful functor, $\ffunct$. In general a forgetful
functor reduces properties and members of a domain category
to render a codomain of concrete sets.
The set category of first interest, $\setcat$, follows:

\begin{definition}{Forgetful functor, $\ffunct$}\label{def:forgetful}, \\[3pt]
  A universal mapping of the large category, $\largecat$, to the category
  of sets:
\begin{align*}
  \ffunct\,:\,\largecat\rightarrow\setcat
\end{align*}
\end{definition}

A trivial application of the forgetful functor acts on the initial category
to yield the empty set:

\begin{equation*}
  \ffunct:\,\catN{0}\rightarrow\varnothing
\end{equation*}

A common shorthand for the forgetful functor are enclosing vertical bars
on categories and collections:

\begin{equation*}
  \ffunct:\,\parsecat{C}\rightarrow\forgetful{C}
\end{equation*}

This shorthand forgetful functor notion, $|\dots|$,
is an intuitive notation from a litany of mathematical
fields to indicate the removal of various properties
or reduction to a property measure of the operand,
such as the reduction of a classical set to a cardinality
measure. The forgetful functor reduces categories to
collections of set objects or identifies categories
consisting of set objects and function arrows.

\begin{definition}{Set Category, $\setcat$}\label{def:setcategory}, \\[3pt]
  The objects of a set category, $\parsecat{C}\in\catobj{Set}$, are sets
\begin{equation*}
  \parsecat{C}=|\parsecat{C}|\Longrightarrow
  \catobj{C}=\{\obk{o}\mid\obk{o}=|\obk{o}|\quad\forall\;\obk{o}\in\catobj{C} \}
\end{equation*}
\end{definition}

The arrow collection, $|\catarr{C}|$, of a set category,
$\parsecat{C}\in\wrpobj{\setcat}$, are functions as
defined in set theory. In summary, a function maps each
member of a domain set to single member of a codomain set.

The restriction of an arrow to a set establishes
corresponding monic and epic propeties
for functions as injective and surjective respectively.
Likewise functor or arrow isomorphism narrows to
function bijection.

The category, $\setcat$, restricts objects of categories to
be sets. Category analysis typically focuses on the study
of arrows in topological structures such as between nodes
of graphs. Locally small categories demonstrate set
structure with arrows relative to locally finite collections of objects.
The arrow $\carr{C}$ functor expresses a transformation from general
categories to categories that are collections of arrow
relative to a pair of objects.
Restricting these collection of arrows to sets relative to each pair of,
domain, codomain, objects defines a locally small category.

Composition of the forgetful functor with the
arrow functor defines a locally small class of categories, $\cathom$:

\begin{definition}{Locally Small Category, $\homcat$}\label{def:locallysmall}
\begin{equation*}\array{llll}
  \wrpobj{\homcat}=\{&\parsecat{C}&\mid&\carr{C}=\forgetful{\carr{C}},
  \;\parsecat{C}\in\largecatobj\} \\[3pt]
  \wrparr{\homcat}=\{&\arr{f}&\mid&\arr{f}\in\largecatarr \\[3pt]
  &\text{and}&&\arrdom{f},\,\arrcod{f}\in\wrpobj{\homcat}\}
\end{array}
\end{equation*}
\end{definition}

More specifically, the collection of arrows
relative to any pair of domain and codomain
object pairs is a set:

\begin{definition}{Locally Small Properties}
\begin{equation*}
  \carrobj{C}=\forgetful{\carrobj{C}}\quad\forall
  \quad\parsecat{C}\in\homcat
\end{equation*}
\begin{equation*}
  \parsecat{C}\in\wrpobj{\homcat}\Longrightarrow\parsecat{C}=\chom{C}
\end{equation*}
or,
\begin{equation*}
  \parsecat{C}\in\wrpobj{\homcat}\Longleftrightarrow\carr{C}\in\wrpobj{\setcat}
\end{equation*}
\end{definition}

As the graph of a locally small category, $\parsecat{C}$,
the nodes of the graph are the object collection, $\catobj{C}$,
and the graph edges between relevent nodes, $\cpair{a}{b}\in\ccpair{C}$,
are represented by the collection, $\homobj{C}\cpair{a}{b}$.
Arrows between edge collections with domain/codomain pairs of
$\homobj{C}$ exist in $\homarr{C}$.

Other strategies in graph analyis restrict both object
and arrow collections to be sets within a category.
Categories that have both small object and arrow collections
are classified as small categories in literature, \cite{awodey2010}.
The collection of small categories is denoted as $\smallcat$.

\begin{definition}{Small Category},
  $\smallcat$\label{def:smallcat} \\[3pt]
  A small category, $\parsecat{C}\in\smallcat$, consists
  of an object collection, $\catobj{C}$, and an arrow collection,
  $\catarr{C}$, that are sets.
  \begin{equation*}
    \smallcat=\{\parsecat{C}\mid \ccobj{C}=\forgetful{\ccobj{C}},\,
    \ccarr{C}=\forgetful{\ccarr{C}},\,\parsecat{C}\in\largecat\}
  \end{equation*}
\end{definition}

The concept of small categories extends to the small functor category.

\begin{definition}{Small Functor Category},
  $\smallfunctcat$}\label{def:smallfunctcat} \\[3pt]
  Consists of a small functor collection, $\smallfunctcatfunct$,
  \begin{equation*}
    \begin{array}{rlrll}
    \smallfunctcatfunct&=&\{\funct{F}&\mid&\funct{F}=\forgetful{\funct{F}},\,
    \funct{F}\in\functcatfunct\,\} \\[3pt]
  likewise,\;&&&& \\[3pt]
    \smallfunctcatcat&=&\{\parsecat{C}&\mid&\parsecat{C}=\functdom{F}\,\text{or}
    \quad\parsecat{C}=\functcod{F},  \\[3pt]
    &&&&\forall\,\funct{F}\in\smallfunctcatfunct\}
  \end{array}
  \end{equation*}
\end{definition}

Small functor category, $\smallfunctcatcat$, objects are necessarily small
since all functors in, $\smallfunctcatfunct$ are small.

A category, $\parsecat{E}$, that is both a small category
and consists exclusively of small objects is a member
of the category class $\expcat$.

\begin{definition}{Exponential category, $\expcat$}\label{def:expcat},
  consists of categories, $\parsecat{E}\in\expcat$,
  where $\parsecat{E}$ is locally small and objects, $\obk{A}\in\catobj{E}$,
  are also small. $\homobj{E}\cpair{A}{B}$ consists of
  a set of arrows denoted exponentially as, $\expab{A}{B}$.
\end{definition}

Transformations between $\homcat$ objects of categories in, $\expcat$,
are properly known as natural.

\begin{definition}{Natural Transformation}\label{def:expnat},
  given a category, $\parsecat{E}\in\expcat$, the set,
  $\homarr{E}\ctpair{A}{B}{A^{\prime}}{B^{\prime}}\in\homarr{E}$,
  where, $\ctpair{A}{B}{A^{\prime}}{B^{\prime}}\in\ccpairn{2}{E}$,
  consist of mappings from objects $\homobj{E}\cpair{A}{B}=\expab{A}{B}$ to
  $\homobj{E}\cpair{A^{\prime}}{B^{\prime}}=\expab{A^{\prime}}{B^{\prime}}$.
\end{definition}

\subsection{Counting with Categories}

The category of all sets, $\setcat$, embraces categories with an
ordinal characteristic. Potentially the entirety of the
category of all sets, $\setcat$, resonates the formalism of Cantor
to develop all set cardenalities.
The finite sets establish an equivalence with the category of
all finite sets, $\fincat$. This section develops a category with countable
objects, $\simplexnn$, is a limit category of finite categories,
$\simplex{n}$.

The extent of set theory as an aspect of category theory
embraces and extends the seminal Von Neumann development of
ordinals from set constructs.
The robust development of ordinal representation with categories
attends an intuitive hypothesis of objects and arrow mappings.
Allegorically, a natural number object, $\simplexnn$,
actually a category, exists as an ordinal construct and reifies
underlying ordinal substructure of more general classes.
Likewise the natural number object consists of finite subcategories, $n$.
The simplest subcategory is the initial object, $\catN{0}$,
def. \ref{def:initial}.

As in set theory the entity of the initial or trivial category
derives existentially from nothing.
As such the initial category, $\catN{0}$, def. \ref{def:initial},
consists of no objects or arrows.
In reference to a set the forgetful functor renders the initial
category as an empty set, a partial qualification as a member of the
small category objects, $\smallcatobj$.

\begin{equation*}
  \ffunct:\,\catN{0}\rightarrow\varnothing
\end{equation*}

As an existential manifestation, the initial category similary
upholds the existential declaraton of any category or object,
eq. \ref{eq:existentialfunct}.

\begin{equation}\label{eq:existentialfunct}
  \mapaob{\catN{0}}{\exists}{\parsecat{C}}
\end{equation}

The dual of the initial category alternately declares the
terminal category, $\catN{1}$, def. \ref{def:terminal}.
The terminal category manifests distinct characteristics
extant from the initial category with an associated
internal object with corresponding identity arrow.
Essentially the terminal category complements the
poverty of constituents in the initial category. 
Notationally the dual relationship of the initial and terminal
category expresses as $\catN{0}=\catN{1}^*$ or $\catN{0}^*=\catN{1}$.
By definition the terminal category acts as a codomain object of a
subcollection of arrows for all objects of a category.
As such, the existence of
the terminal category complements the initial category
by pretext of a univeraal functor, $\funct{\forall}$,
mapping all objects of a category to a codomain terminal functor.

The terminal category is a prototypical model of a
general singleton category minimally consisting of one
object and one arrow.

Qualifying any category $\parsecat{C}$ as an object of a category requires
the category to be distinguished with a unique identity functor:

\begin{equation}\label{eq:categoryid}
  \mapaob{\parsecat{C}}{\oper{id}_{\parsecat{C}}}{\parsecat{C}}
\end{equation}

Equivalently the initial category acts as the
domain for the declaration of singletons from members of a codomain
object, genrally an $n-category$, fig. \ref{eq:singletoncat}.

\begin{equation}\label{eq:categoryid}\label{eq:singletoncat}
  \mapaob{\catN{1}}{\obk{c}}{\parsecat{D}}
\end{equation}

For a general example, the functor, $\funct{c}$, maps the domain, $\catN{1}$,
to a subcategory, $\csub{\parsecat{C}}{\parsecat{D}}$.
The subcategory, $\parsecat{C}$, is a singleton category
consisting of an arbitrary solitary object,
$\obk{c}\in\parsecat{D}$ with associated
identity arrows $\arrid{c}$ for each necessary category order.

A singleton construction generalizes to a UMP
functor $\umpclass_{\catN{1}}$ acting on the general collection of categories,
$\functcatcat$. For a category, $\parsecat{C}\in\functcatcat$,
as a domain and a singleton category codomain, $\singletoncat{C}$.
Explicitly, the singleton UMP subordinates a category, $\parsecat{C}$,
to an object with an identity functor, $\functid{C}$, eq. \ref{eq:categoryid}.

\begin{equation}\label{eq:generalsingleton}
  \mapaob{\catN{1}}{\parsecat{C}}{\singletoncat{C}}
\end{equation}

Interesting to the herein development is the mapping
of the initial category to the object with identity functor
of the singleton category, $\singleton{\catN{0}}$.

Another, extension by UMP of a general category, $\parsecat{C}$,
as a domain to the special singleton category, $\singletoncat{C}$, as
codomain. Denote this UMP as, $\umpclassp{\gtrdot}$ defines distinct
arrows with domain object in $\ccobj{C}$ and common codomain object
as the singular category, $\parsecat{C}\in\singletoncat{C}$.

\begin{equation}\label{eq:singletonump}
  \mapaob{\pazocal{C}}{\gtrdot}{\singletoncat{C}}
\end{equation}

Combining the functor collection, eq. \ref{eq:singletonump},
with the singleton codomain, eq. \ref{eq:generalsingleton},
yields the UMP, $\umpclassp{succ}$ defining a general category,
$\parsecat{C}$, successor, $\umpclasspc{succ}{C}$, eq. \ref{eq:successorcat}.

\begin{definition}{Successor UMP}\label{eq:successorcat}
\begin{equation*}\array{lll}
\wrpcat{\umpclasspc{succ}{C}}&=&\ccobj{C}\cup
        \wrpcat{\singletoncat{C}} \\[3pt]
\wrpfunct{\umpclasspc{succ}{C}}&=&\ccarr{C}\cup
        \wrpfunct{\singletoncat{C}}\cup \\[3pt]
        &&\{\funct{F}\mid\parsecat{O}=\functdom{F}\;\text{and}\;
        \parsecat{C}=\functcod{F}, \\[3pt]
        &&\hspace{30pt}\parsecat{O}\in\ccobj{C}\}
\end{array}
\end{equation*}
\end{definition}

A more practical application of the successor UMP, $\umpclassp{succ}$,
eq. \ref{eq:successorcat}. applies to a specific category of categories,
$\simplexnn$. The category, $\simplexnn$, conspicuously adopts the symbol,
$\Delta$, as a traditional reference to the collection of simplex graphs,
widely denoted as the coxeter group, $\mathbf{A_n}$. The simplex
category, $\simplex{n}\in\simplexnn$. consists of $n$ objects with
$\frac{1}{2}n(n+1)$ arrows. In contrast the traditional simplex graph
does not have identity arrows, rather consisting of simple vertices
instead of objects and edges connecting verticies
rather than the directed arrows of categories.
The comcept of simplex is the chosen mpdel to develop 
a category framework for the natural numbers, $\mathbb{N}$.

To begin the $0-simplex$ equivalates to the initial category, $\catN{0}$.
The $0-simplex$ equivalates as the $\simplex{0}$ category cosisting
of no objects or arrows.
A consistent ordinal sequence of categories derived from the initial
category, $\simplex{0}$, by recursive application of the UMP,
$\umpclassp{succ}$. The ordinal categories are denoted as
$\simplex{n}$. Identity arrows for each object of the category,
$\simplex{n}$, are assumed and specified, eq. \ref{eq:categoryid}.
The initial category is denoted as, $\simplex{0}=\catN{0}$.
A functor mapping from the initial category, $\simplex{0}$ to
the ordinal one category, $\simplex{1}$, is specified by, eq.
\ref{eq:generalsingleton}. 

\begin{equation}\label{eq:initialsingleton}
\array{ll}
  &\mapaob{\simplex{0}}{\oper{succ}}{\singleton{\simplex{0}}} \\[3pt]
\text{where}&\simplex{1}\;=\;\singleton{\simplex{0}}
\end{array}
\end{equation}

Continuing the oridinal sequence further is partially satisfied by
using the singleton result, $\ref{eq:generalsingleton}$, in
a product with the input ordinal category:

\begin{equation}\label{eq:simplexobject}
  \mapaob{\simplex{n}}{\oper{succ}}{\simplex{n+1}}
\end{equation}

Obvious properties, eq. \ref{eq:simplexproperty},
derive from the structure imposed by the
successor UMP, $\umpclassp{succ}$, by definition \ref{eq:successorcat}.

\begin{equation}\label{eq:simplexproperty}
\array{ll}
 \simplex{n}&\lessdot\simplexnn\;\forall\, n\in\mathbb{N} \\[3pt]
 \simplex{m}&\lessdot\simplex{n}\;\forall\, m,\,n\in\mathbb{N}\;\text{and}\;
 m\leq n
\end{array}\end{equation}

The monad, $\umpclassp{succ}$, maps the
domain category, $\simplex{n}$, to a category, $\simplex{n+1}$.
In elementary fashion the successor monad, $\umpclassp{succ}$,
maps the inital category, $\catN{0}$, to the terminal category, $\catN{1}$.
The universal singleton map demonstates the embedding necessary to
begin:

Ad infinitum the process
generates a category, $\simplexnn$, with an object
cardinality of the natural numbers, $\mathbb{N}$,
fig. \ref{fig:naturalnumbercat}.

\begin{equation*}
  \mapaob{\simplexnn}{\obk{succ}}{\simplexnn}
\end{equation*}

\begin{figure}
     \begin{tikzpicture}[
            > = stealth, % arrow head style
            shorten > = 1pt, % don't touch arrow head to node
            auto,
            node distance = 3cm, % distance between nodes
            semithick % line style
        ]

        \node[] (1) {$\catN{1}$};
        \node[] (N) [right of=0] {$\simplexnn$};

        \path[->] (1) edge node[above] {$\simplex{0}$} (N);
        \path[->] (N) edge [reflexive right]
                      node[anchor=center,midway,right] {$\oper{succ}$} (N);        
       \end{tikzpicture}
       \caption{Ordinal collection, note that arrows emerging from terminal
       object denote constants}\label{fig:naturalnumbercat}
\end{figure}

Transforming the natural number category objects, $\simplexnn$,
with the forgetful functor yields a set representation
of the natural numbers as defined by Von Neumann.

\begin{equation*}
  \ffunct_{,1}:\,\simplexnn\rightarrow\mathbb{N},
\end{equation*}

Finite number categories relative to actual
arrow construction develops abstractly thus far.
As categories the assingment of arrows between objects
requires careful attention. Apart from the requisite identity
arrows, a simple construct to follow
is that of the $n-simplex$ category representation for each
natural number category, $\simplexnn$. In this construct
each of the $n$ distinct objects of $\simplex{n}$ are domains
of new arrows to the $n+1^{\text{st}}$ object. Choose the $n+1^{st}$
object the category $\simplex{n+1}$.

\subsection{Graphs}

Category objects and arrows elicit intuitive
parallels with directed graph vertices and paths,
although categories admit general objects.
Mac Lane, \cite{maclane1998}, enlisted the idea of
graphs as metacategories to introduce category theory.
As the development graph theory arose independently of
category theory, an alignment and distinction
of terminologies is appropriate. Distinctly,
graphs consist of simple vertices and edges bereft
of object structure and the compositional
algebra of arrows.
This section develops from bottom up through the
encapsulation and endowment of graphs with
minimal category properties. A top down development
narrows the definition of general categories to
collections that at least locally resemble graphs.
A dual approach to the introduction of graphs
into category theory establishes a broad repetoire
of tools for analysis and construction of categories
for various fields of study.

From the bottom up begin with the definition
of a general graph with simple collections
of vertices and edges of unspecified cardinality
or status as sets.

\begin{definition}{Graph}\label{def:graph}, $\graph{G}$,
  consists of a collection of vertices,
  $\graphv{G}$, and a collection of edges,
  $\graphe{G}$, such that each edge
  has a source vertex and target vertex in, $\graphv{G}$.
  Equivalently, there is a source arrow, $\arr{s}$,
  and a target arrow, $\arr{t}$, both originating
  from the domain arrow collection, $\graphv{G}$, and
  ending upon the vertex collection, $\graphe{G}$.
  \begin{equation*}
    \begin{array}{lll}
      \quad\bullet\quad&\textbf{(Source)}\;
                       &\mapaob{\graphe{G}}{s}{\graphv{G}} \\[3pt]
      \quad\bullet\quad&\textbf{(Target)}\;
                       &\mapaob{\graphe{G}}{t}{\graphv{G}}
    \end{array}
  \end{equation*}
\end{definition}

Association between a domain and codomain pair of graphs is
supported by a graph homomorphism which preserves edge associations
between source and target vertices.

\begin{definition}{Graph homomorphism}\label{def:graphhomo},
  $\phi$, is a mapping $\mapaob{\graph{G}}{\phi}{\graph{H}}$
  that transforms graph, $\graph{G}$ to graph, $\graph{H}$.
  \begin{equation*}
    \begin{array}{lll}
      \quad\bullet\quad&\textbf{(Graph)}\;
                  &\mapaob{\graph{G}}{\phi}{\graph{H}} \\[3pt]
      \quad\bullet\quad&\textbf{(Vertices)}\;
                  &\mapaob{\graphv{G}}{\phi}{\graphv{H}} \\[3pt]
      \quad\bullet\quad&\textbf{(Edges)}\;
                  &\mapaob{\graphe{G}}{\phi}{\graphe{H}} \\[3pt]
      \quad\bullet\quad&\textbf{(Source)}\;
                  &\mapaob{\graphe{\phi(G)}}{\phi(s)}{\graphv{\phi(G)}} \\[3pt]
      \quad\bullet\quad&\textbf{(Target)}\;
                  &\mapaob{\graphe{\phi(G)}}{\phi(t)}{\graphv{\phi(G)}}
    \end{array}
  \end{equation*}
\end{definition}

The formalism of quivers provides an encapsulation of
graphs into a minimal category structure, with a
simple extension of graph homomorphism
into quiver category and functor collections

Each graph directly extends vertex and edge collections
as objects and source and target mappings as arrows
into a walking quiver category. Vertex and edge
identity arrows complete the walking quiver as
a category. The explicit definition of 
the walking quiver as a category. 

\begin{definition}{Walking Quiver}\label{def:walkingquiver},
  consider a quiver map, $\parsecat{Q}$, that uniquely maps any graph,
  $\graph{G}$, into a distinct category, $\wquiver{G}$.
  $\wquiver{G}$, is a category consisting of two objects
  and four arrows relative to a graph, $\graph{G}$.
  $\wrapobj{\wquiver{G}}=\{\graphv{G},\,\graphe{G}\}$
  and $\wraparr{\wquiver{G}}=\{\arr{s},\,\arr{t},\,
  \obk{id}_{\graphv{G}},\,\obk{id}_{\graphe{G}}\}$,
  where $\obk{id}_{\graphv{G}}$ and $\obk{id}_{\graphe{G}}$
  are the identity arrows for the objects, $\graphv{G}$
  and $\graphe{G}$, respectively. $\arr{s}$ and $\arr{t}$
  are the source and target arrows from edge object,
  $\graphe{G}$, to vertex object, $\graphv{G}$.
\end{definition}

A minimal extension of a graph homomorphism renders a
quiver functor of domain and codomain
walking quivers directly follows:

\begin{definition}{Quiver functor}\label{def:quiverfunctor},
  $\funct{\phi}$, is a graph homomorphism
  with the extended formality required for source and target
  arrows  from edge to vertex object collections,
  along with the identity arrows for the vertex and edge objects.
  $\wquiver{G}$ to a codomain, $\wquiver{H}$,
  $\mapaob{\wquiver{G}}{\phi}{\wquiver{H}}$.
  \begin{equation*}
    \begin{array}{lll}
      \quad\bullet\quad&\textbf{(Vertex Id)}\;
            &\mapaob{\obk{id}_{\graphv{G}}}{\phi}{\obk{id}_{\graphv{H}}} \\[3pt]
      \quad\bullet\quad&\textbf{(Edge Id)}\;
            &\mapaob{\obk{id}_{\graphe{G}}}{\phi}{\obk{id}_{\graphe{H}}} \\[3pt]
    \end{array}
  \end{equation*}
\end{definition}

A top down transformation of general categories to quivers
requires a specialized forgetful functor, $\ffunct$.
Reletive to the potentially complex structure of category objects
a graph vertex is a singleton consisting of an
identity to distinguish one vertex from another.
Conveniently distinction between category objects is
uniquely fulfilled by identity arrows.
Henceforth, the a forgetful functor of interest segregates
identity arrows from the domain category arrow collection as the
graph vertices.
Sans composition algebra, arrows of a category proximate edges.
The forgetful functor realizes this proximation however as a
composition with a specialized Hom UMP to map an edge collection.
Such an arrow treansform is specialized by the usual partitioning of
category arrows as objects with common domain/codomain pairs
although without identity arrows.
In composition, the forgetful functor translates the
identity of each partition object to an edge.
To complete the transformation of a category to a walking quiver
the $\oper{dom}$ and $\oper{cod}$ arrows are used as the source
and target arrows of the graph, respectively.
In completion the vertex and edge collections are assinged identity arrows
to complete the definition of a walking quiver from a general category.

\begin{definition}{Forgetful Quiver Mapping}\label{def:forgetfulquiver}
%\begin{equation}
\begin{gather}
  \parsecat{G}=\wquiver{G}=\forgetgrf{\parsecat{C}}
\end{gather}
%\end{equation}
\begin{equation*}
\begin{array}{rl}
\parsecat{G}\thicksim&\text{Walking quiver}\thicksim\wquiver{G} \\[3pt]
\graphv{G}=&\wrapobj{\forgetgrf{\parsecat{C}}}
               =\{\arrid{o}\mid\obk{o}\in\ccobj{C}\} \\[3pt]
  \graphe{G}=&\wraparr{\forgetgrf{\parsecat{C}}}=
               \wrapobj{\forgetgrf{\hat{\parsecat{C}}^{\rightarrow}}} \\[3pt]
  \text{where}\hspace{30pt}&\quad \\[3pt]
  \wrapobj{\hat{\parsecat{C}}^{\rightarrow}}\cpair{a}{b}=&
  \{\arr{r}\mid\arrdom{r}=\obk{a},\;\arrcod{r}=\obk{b} \\[3pt]
  \quad&\hspace{24pt}\text{and}\;\arr{r}\neq\arrid{a}\} \\[3pt]
  \graphe{G}=&\{{id}_{\wrapobj{\hat{\parsecat{C}}^{\rightarrow}}\cpair{a}{b}}
               \mid\wrapobj{\hat{\parsecat{C}}^{\rightarrow}}\cpair{a}{b}\in
               \wrapobj{\hat{\parsecat{C}}^{\rightarrow}}\}
\end{array}
\end{equation*}
\end{definition}

Mapping a category into a respective walking quiver
is detailed as follows:

\begin{equation*}
\begin{array}{lll}
  \parsecat{G}&\thicksim&\text{walking quiver representation} \\[3pt]
  \quad&\quad&\text{of category,}\quad\parsecat{C} \\[3pt]
  \quad&\quad&\text{labeling an object in}\;\ccobj{C} \\[3pt]
  \graphv{G}&\thicksim&\text{Vertex collection} \\[3pt]
  \graphe{G}&\thicksim&
           \text{forgets identity arrows and} \\[3pt]
  \quad&\quad&\text{reduces residual arrows to edges} \\[3pt]
  \ccobj{G}&=&\{\graphv{G},\,\graphe{G}\} \\[3pt]
  \ccarr{G}&=&
        \{\arr{s},\,\arr{t},\,\obk{id}_{\graphv{G}},\,\obk{id}_{\graphe{G}}\}
\end{array}
\end{equation*}
\begin{equation*}
    \begin{array}{ll}
      \quad\bullet\quad\textbf{(Source)}\quad\arr{s}(\graphe{G})=&
       \{\obk{v}\mid\obk{v}=\arrdom{f}, \\[3pt]
        \quad&\;\,\qquad\obk{v}\in\graphv{G},\,
         \arr{f}\in\graphe{G}\}\quad \\[3pt]
      \quad\bullet\quad\textbf{(Target)}\quad\arr{t}(\graphe{G})=&
       \{\obk{v}\mid\ovk{v}=\arrcod{f}, \\[3pt]
        \quad&\;\,\qquad\obk{v}\in\graphv{G},\,\arr{f}\in\graphe{G}\}
   \end{array}
\end{equation*}

The forgetful quiver UMP, $\functscr{U}$, maps endomorphic arrows that are not
identity arrows of a category to loops in the walking quiver. 

Functors between categories are also transformed by the
forgetful quiver mapping:

\begin{gather}
  \mapaob{\parsecat{G}}{\phi}{\parsecat{H}}=
  \functscr{U}(\mapaob{\parsecat{C}}{\obk{F}}{\parsecat{D}})
\end{gather}
\begin{equation*}
\begin{array}{rll}
  \parsecat{C},\,\parsecat{D}&\in\largecatobj,\quad
  \funct{F}\in&\largecatarr \\[3pt]
  \parsecat{G},\,\parsecat{H}&\in\wrapobj{\largegrf},\quad
  \funct{\phi}\in&\wraparr{\largegrf}
\end{array}
\end{equation*}
\begin{equation*}
\begin{array}{rl}
  \parsecat{G}\thicksim&\text{Walking quiver}\thicksim
                         \wquiver{G}=\forgetgrf{C} \\[3pt]
  \parsecat{H}\thicksim&\text{Walking quiver}\thicksim
                         \wquiver{H}=\forgetgrf{D} \\[3pt]
  \mathsf{G},\,\mathsf{H}\thicksim&\text{Graphs rendered by}\;
                                    \wquiver{G},\,\wquiver{H} \\[3pt]
\funct{\phi}=&\forgetgrf{\obk{F}}\thicksim\text{Functor to Quiver map}
\end{array}
\end{equation*}

Express the universal mapping of general categories into a large graph
category, $\largegrf$.

\begin{equation*}
  \mapaob{\largecat}{\functscr{U}}{\largegrf}
\end{equation*}

The graph UMP mapping, $\functscr{U}$, on the small
categories specifies the small graph collection, $\smallgrf$.

\begin{equation*}
  \mapaob{\smallcat}{\functscr{U}}{\smallgrf}
\end{equation*}

Construction of free algebraic structures from graphs requires
a more robust representation of edge loops for each vertex.
Fortunately this generalization is supported by directly using
an Hom UMP with the forgetful quiver mapping, the result
is the reflexive quiver mapping, $\rffunct$. The reflexive quiver
mapping requires each vertex to have an identity edge, a loop, in
conformity with the identity arrow of category theory.
Identity edges are existential entities confined to the distinction
of vertices. The category associated with the reflexive quiver mapping
supports a distinct monic arrow mapping the vertex object to the
subcollection of identity edges within the edge object.

\begin{definition}{Reflexive Quiver Mapping}\label{def:rforgetfulquiver}
%\begin{equation}
\begin{gather}
  \parsecat{G}=\wquiver{G}=\rforgetgrf{\parsecat{C}}
\end{gather}
%\end{equation}
\begin{equation*}
\begin{array}{rl}
\parsecat{G}\thicksim&\text{Reflexive quiver}\thicksim\wquiver{G} \\[3pt]
\graph{G}\thicksim&\text{reflexive graph} \\[3pt]
\graphv{G}=&\wrapobj{\rforgetgrf{\parsecat{C}}}
               =\{\arrid{o}\mid\obk{o}\in\ccobj{C}\} \\[3pt]
  \graphe{G}=&\wraparr{\rforgetgrf{\parsecat{C}}}=
               \wrapobj{\rforgetgrf{\carrobj{C}}} \\[3pt]
  \text{where}\hspace{30pt}&\quad \\[3pt]
  \graphe{G}=&\{{id}_{\carrobj{C}\cpair{a}{b}}
               \mid\carrobj{C}\cpair{a}{b}\in
               \carrobj{C}\}
\end{array}
\end{equation*}
\end{definition}

Mapping a category into a respective reflexive quiver
is detailed as follows:

\begin{equation*}
\begin{array}{lll}
  \parsecat{G}&\thicksim&\text{reflexive quiver representation} \\[3pt]
  \quad&\quad&\text{of category,}\quad\parsecat{C} \\[3pt]
  \quad&\quad&\text{labeling an object in}\;\ccobj{C} \\[3pt]
  \graphv{G}&\thicksim&\text{Vertex collection} \\[3pt]
  \graphe{G}&\thicksim&
           \text{reduces residual arrows to edges} \\[3pt]
  \ccobj{G}&=&\{\graphv{G},\,\graphe{G}\} \\[3pt]
  \ccarr{G}&=&
  \{\arr{s},\,\arr{t},\,\arr{i},\,
               \obk{id}_{\graphv{G}},\,\obk{id}_{\graphe{G}}\} \\[3pt]
  \arr{i}&\thicksim&\text{arrow mapping from}\;\graphv{G}\; \\[3pt]
  \quad&\quad&\text{to identity arrow subcollection}\;
               \{\arrid{v}\mid\obk{v}\in\graphv{G}\}
\end{array}
\end{equation*}
\begin{equation*}
    \begin{array}{ll}
      \quad\bullet\quad\textbf{(Source)}\quad\arr{s}(\graphe{G})=&
       \{\obk{v}\mid\obk{v}=\arrdom{f}, \\[3pt]
        \quad&\;\,\qquad\obk{v}\in\graphv{G},\,
         \arr{f}\in\graphe{G}\}\quad \\[3pt]
      \quad\bullet\quad\textbf{(Target)}\quad\arr{t}(\graphe{G})=&
       \{\obk{v}\mid\ovk{v}=\arrcod{f}, \\[3pt]
        \quad&\;\,\qquad\obk{v}\in\graphv{G},\,\arr{f}\in\graphe{G}\} \\[3pt]
      \quad\bullet\quad\textbf{(Reflex)}\quad\arr{i}(\graphv{G})=&
       \{\arrid{v}\mid
        \,\obk{v}\in\graphv{G},\,\arrid{v}\in\graphe{G}\}
   \end{array}
\end{equation*}

The reflexive quiver generates a free category,
essentially, structureing general algebras.
From the bottom up a free category is developed
through the concatenation of corresponding edges of the
reflexive quiver. Externally, a functor composition acting
on a reflexive quiver implies a concatenation operation
on an underlying sequences of edges.
Correspondence implies that the tail of and edge
matches the source of the next edge to form a concatenation
sequence. Concatenation sequences are refered to as words.
For convenience with category operations; edges use
arrow notation with the source as a domain and target
as codomain. For small graphs a correspondence is
expressed as a collection of sequences, \ref{eq:edgeseq}:

Given $\earr{l}\in\graphe{G}^l$ and $\earr{r}\in\graphe{G}^m$
\begin{equation*}
\earr{l}=\earr{l}\star\varnothing=\varnothing\star\earr{l}
\end{equation*}
\begin{equation*}\label{eq:edgeconcat}
\begin{array}{rlll}
\earr{l}\star\earr{r}&\thicksim&\text{concatenation of words}
                               ,&\left\{\earr{l},\,\earr{r}\right\} \\[3pt]
\left\{\earr{l},\,\earr{r}\right\}&=&\left\{\earr{r}\right\}
                               ,&\earr{l}=\varnothing \\[3pt]
\left\{\earr{l},\,\earr{r}\right\}&=&\left\{\earr{l}\right\}
                               ,&\earr{r}=\varnothing
\end{array}
\end{equation*}
\begin{equation}\label{eq:edgeseq}
\begin{array}{llll}
\gamma^n&=&\gamma^k\circ\gamma^m,&n=k+m,\,k,\,m\in\mathbb{N} \\[3pt]
\gamma^0\graphe{G}&=&\left\{\varnothing\right\}&
                                 \quad\text{the empty word set} \\[3pt]
\gamma\graphe{G}&=&\graphe{G}\cup\left\{\varnothing\right\}& \\[3pt]
\gamma^n\graphe{G}&=&\gamma^{n-1}\graphe{G}\star\graphe{G}=&\quad \\[3pt]
          \quad&\quad&\quad\{\earr{l}\star\earr{r}\mid&
                       \earr{l}\in\gamma^{n-1}\graphe{G}\;
                       \text{and}\;\earr{r}\in\graphe{G}\;\\[3pt]
          \quad&\quad&\quad&\text{where}\;\earrdom{l}=\earrcod{r}\} \\[3pt]
\quad\text{or},&\qusd&\quad&\quad \\[3pt]
\gamma^n\graphe{G}&=&\graphe{G}\star\gamma^{n-1}\graphe{G}=&\qusd \\[3pt]
          \quad&\quad&\quad\{\earr{l}\star\earr{r}\mid&
                       \earr{l}\in\graphe{G}\;
                       \text{and}\;\earr{r}\in\gamma^{n-1}\graphe{G}\;\\[3pt]
          \quad&\quad&\quad&\text{where}\;\earrdom{l}=\earrcod{r}\}
\end{array}
\end{equation}

Given the cardinality of a edge collection, $\kappa(\graphe{G})$,
the concatenation of $n$ length sequences generates,
$\kappa(\gamma^n\graphe{G})$, distinct words of lengths, $0$ to $n$.
Hence, $w\in\gamma^n\graphe{G}$, is a word of length
$\oper{len}(w)\in\left[0,n\right]$.
A subword is a subsequence of contiguous edges of a word.
Each sequence, $\earr{r}$, of the collection, $\gamma^n\graphe{G}$,
begins with a reference to an source vertex, $\earrdom{r}$
extending to a target vertex, $\earrcod{r}$.
Cycles are sequences of edges that begin and end at the same vertex
with all proper subwords having non-corresponding source or target vertices.
An identity edge is an empty word acting as a concatenation identity.
Concatenation is not in general commutative with the source of the
first operand matching the target of the second operand otherwise
concatenation is not defined.
Elucidating the word construction of the reflexive quiver,
\ref{eq:edgeseq}, with functors, $\gamma^n$:

\begin{equation}\label{eq:rquiverseq}
\begin{array}{lll}
\wrapobj{\nwquiver{1}{G}}&=&\{\graphv{G},\,\gamma\graphe{G}\} \\[3pt]
\wrapobj{\nwquiver{n}{G}}&=&\{\graphv{G},\,\gamma^n\graphe{G}\} \\[3pt]
\gamma^n&=&\gamma^k\circ\gamma^m,\,\\[3pt]
           \quad&\quad&\quad n=k+m,\,k,\,m,\,n\in\mathbb{N}
\end{array}
\end{equation}
\begin{gather}\label{eq:quiverseq}
\mapaob{\wquiver{G}}{\gamma^n}{\nwquiver{n+1}{G}} \\[3pt]
\mapaob{\nwquiver{k}{G}}{\gamma^m}{\nwquiver{k+m}{G}}
\end{gather}

The quiver, $\Gamma$, is the dual of the forgetful
reflexive functor, $\rffunct$.
A quiver consists of a collection of functors that
map a reflexive quiver of genereated word collections, $\gamma^n\graphe{G}$,
into a free category, $$.

\begin{definition}{Quiver}\label{def:quiver},
  A quiver, $\quiver{G}$, is a functor mapping of the
  of the reflexive quiver, $\rquiver{G}$, of a graph, $\graph{G}$,
  into a category, $\parsecat{C}$.
  Given a category, $\parsecat{C}$,
  the category of quivers consists of an object collection
  of quivers, $\wrapobj{\quivercat{C}}$, and an arrow
  collection of natural transformations between quivers,
  $\wraparr{\quivercat{C}}$. As an example consider
  the quivers 
  \begin{equation*}
    \begin{array}{ll}
      \quad\bullet\quad&\quiver{G}\in\wrapob{\quivercat{C}}
    \end{array}
  \end{equation*}
\end{definition}

The comparison of the definition of graph versus category
introduces the definition of a function class, $\graphclass{G}$,
from a graph, $\graph{G}$, into the category $\graphfree{G}\in\smallcat$.

\begin{definition}{Graph Category}\label{def:graphcat}, $\graphfree{G}$,
  is a category of categories. Each category, $\parsecat{C}\in\graphfree{G}$,
  has a function, $\funct{f}\in\graphclass{G}$,
  from $\graph{G}$ into into $\parsecat{C}$:
\begin{equation*}  
\mapaob{\graph{G}}{\obk{f}}{\graphfree{G}}
\end{equation*}
\begin{equation*}  
  \graphfree{G}=\{\parsecat{C}\mid\mapaob{\graph{G}}{f}{\parsecat{C}}\;
  \forall\funct{f}\in\graphclass{G})
\end{equation*}
\end{definition}

The functional mapping of graphs into categories
supports the analysis of categories as local graphs.
The Hom category provides a basis to understanding
a class of categories that are locally graphs.

\subsection{Set Arrows}

This sections focuses on collective properties
of arrows in $\setcat$. The most basic property
is prorder:

\begin{definition}{Preorder}\label{def:preorder},
\begin{itemize}
\item\textbf{(Relation)} preorder, \csub{C_{\leq}}{\parsecat{C}}$ \\[3pt]
\item\textbf{(Transitive)} if $a\leq b$ and $b\leq c$ then $a\leq c$
\item\textbf{(Symmetric)} if $a\leq b$ and $b\leq a$ then $a=b$
\end{itemize}
\end{definition}

Every pair of objects in $\catobj{(Set\times Set)}$ 
have only one preorder arrow.

 preorders are set inclusion, $\lessdoteq$ 

Set composition was used in the previous section to
define the ordinals similarly the concept of set composition
and pair class defines involutive the Cartesian product mapping of
the pair class. Caresian product maps a pair of set domains to a codomain of
pairs. Each element of the codomain is a pair of constituent
elements from the domain pair.

\begin{definition}{Cartesian Product},denoted by the
  operator $\times$, maps  set of pairs 
  from sets A and B:
  \begin{equation}
    \times:\,\mathfrak{P}\rightarrow\mathfrak{P}
  \end{equation}
  \begin{equation}
    A\times B=\{(a,b)\mid a\in A\,\,\text{and}\,\,b\in B\}
  \end{equation}
\end{definition}


Basic set operations of intersection and union provide
str. A loose introduction
to algebra is demonstrated with these operations. In
particular a $\sigma-algebra$.

The simplest relation on sets is that of subset.
Set product operations to build complex set
structure for discovery an representation of
broader relations between sets and elements.

Derivation of the ordinals,$\mathbb{N}$,
introduced an order property for elements of sets.
Cartesian product requires an an order dependent binary construction
on two arbitrary input sets, $A$ and $B$. Cartesian product
on on pairs of input sets defines a codomain,
$\mathfrak{P}$, of ordered pairs.
Unlike intersection and union operations, the cartesian product
operation is not commutative:

\begin{equation}
    \textbf{(Noncommutativity)}\quad A\times B\neq B\times A
\end{equation}

  A cartesian product on a collection of $n$ sets
  \begin{equation}
    A={A_1,...,A_n}
  \end{equation}
  is a set of $n-tuples$, for convienience an index set of
  natural numbers, $\mathbb{N}$, is used, $[n]\in\{1...n\}$:
  \begin{equation}
    \prod^\times_{i\in[n]}A_i=\{(a_1,...,a_n)\mid a_i\in A_i\,,i\in[n]\}
  \end{equation}
Mapping of a cartesian product defines a class of binary functions:

\begin{equation}
  f:\,A\times B\rightarrow C
\end{equation}

This defines a codomain, $C$, of $f$ for $A\times B$:

\begin{equation}
  C\supset {f(a,b)\mid\forall a\in A\,,b\in B\}
\end{equation}

Projection operations on the set,
$\mathfrak{P}$, discriminates the ordered constituents of a pair:

$\forall (a,b)\in\mathfrak{P}$
\begin{align}
  fst\,(a,b)=a\label{eq:fst}\\
  snd\,(a,b)=b\label{eq:snd}
\end{align}

Although Cartesian product is not commumtative it does

$\forall (a_1a_2,...,a_n)\in\mathfrak{T}_n$, $n>0$
\begin{align}
  head\,(a_1,a_2,...,a_n)=a_1\label{eq:head}\\
  tail\,(a_1,a_2,...a_n)=(a_2,...,a_n)\label{eq:tail}
\end{align}

The composition of the function $succ:\,\mathbb{N}\rightarrow\mathbb{N}$
defines the binary function of integral addition
$+:\,\mathbb{N}\times\mathbb{N}\rightarrow\mathbb{N}$

\begin{align}
  \textbf{(Composition:$\circ$)}\quad succ\circ succ^n=succ^n\circ succ\label{eq:comp}\\
  \textbf{(Addition)}\quad succ^k\circ succ^l\,0=k+l\label{eq:add}
\end{align}

The function,  $succ$, introduces concepts of recursion
and order.

\section{Appendix}

\bibliography{sample-paper}

\bibliographystyle{prsty}
\begin{thebibliography}{99}
\bibitem{cartan1966}Cartan,\'{E}., ``The Theory of Spinors'', Hermann, [1966]
\bibitem{cartan1913}Cartan,\'{E}., ``Les Groupes Projectifs qui ne laissent
  invariante aucune multiplicit\'{e} plane'', Bull. Soc. Math. France, [1913]
\bibitem{grothendieck1957}Grothendieck,A., ``Sur quelques points d`Alg\`{e}bra Homologique'', T\^{o}hoku Math. J., 9, pp. 119-221, [1957]
\bibitem{brauerweyl1937}Brauer,R. and Weyl,H., ``Spinors in n Dimensions'', Am. J. Math., 57, pp. 425-449, [1937]
\bibitem{russell1902}Russell,B., Letter to Frege,In Heijenoort 1967, pp. 124-125, [1902]
\bibitem{russell1903}Russell,B., ``The Principles of Mathematics'', Cambridge Univ. Press, Cambridge, Vol. I, [1903]
\bibitem{pauli1927}Pauli,W., ``Zur Quantenmechanik des Magnetischen Elektrons'', Z. Phys., 43, pp. 601-623, [1927]
\bibitem{zermelo1908}Zermelo,E., ``Untersuchungen \"{U}ber die Grundlagen der Mengeniehre``, Math. Ann., 65, pp. 261-281, [1908]
\bibitem{schafer2008}Schafer,R.D., ``An Introduction to Nonassociative Algebras'', Project Gutenberg(Public Domain USA). Internet, [2008]
\bibitem{dirac1928}Dirac,P.A.M., ``The Quantum Theory of the Electron'', Proc. R. Soc. \(London\), [1928]
\bibitem{birkoff1935}Birkoff,G.D., ``On the Structure of Abstract Algebras'', Proc. Cambridge P. Soc. 31, pp. 433-454, [1935]
\bibitem{jipsenrose1992}Jipsen,P.,Rose,H.``Varieties of Lattices'', Springer-Verlag,Berlin-Heidelberg, [1992]
\bibitem{hodges1993}Hodges,W., ``Model Theory'', Cambridge Univ. Press, Cambridge, [1993]
\bibitem{lawvere1965}Lawvere,F.W., ``An Elementary Theory of the Category of Sets'', Proc. N. Acad. Sc., PNAS, [1965]
\bibitem{lawvere1997}Lawvere,F.W.,Shanuel,S.H., ``Conceptual Mathematics, A first Introduction to Categories'', Cambridge Univ. Press, Cambridge, [1997]
\bibitem{awodey2010}Awodey,S., ``Category Theory'', Oxford Univ. Press, Oxford, [2010]
\bibitem{barrwells1990}Barr,M.,Wells,.C, ``Category Theory for Computing Science'', Prentice Hall, [1990], pdf version online [1998]
\bibitem{lang2002}Lang,S., ``Algebra'', Springer-Verlag, NY, [2002]
\bibitem{maclane1986}Mac Lane,S., ``Mathematics Form and Function'', Springer-Verlag, NY, [1986]
\bibitem{maclane1998}Mac Lane,S., ``Category Theory for the Working Mathemetician'', Second Edition, Springer-Verlag, NY, [1998]
\bibitem{bourbaki1989}Bourbaki,N., ``Algebra I'', Springer-Verlag, Berlin Heidelberg, [1989]
\bibitem{bourbaki22003}Bourbaki,N., ``Algebra II'', Springer-Verlag, Berlin Heidelberg, [2003]
\bibitem{hungerford1974}Hungerford,T.W., ``Algebra'', Springer-Verlag, NY, [1974]
\bibitem{burris1981}Burris,S.,Sankappanavar,H.P., ``A Course in Universal Algebra'', Springer-Verlag, NY, [1981]
\bibitem{rotman1998}Rotman,J., ``Galois Theory'', Springer-Verlag, NY, [1998]
\bibitem{fultonharris2004}Fulton,W., Harris,J., ``Representation Theory: A First Course'', Springer-Verlag, NY, [2004]
\bibitem{humphreys1972}Humphreys,J., ``Introduction to Lie Algebras and Representation Theory'', Springer-Verlag, NY, [1972]
\bibitem{brouwer1911}Brouwer,L.E.J., ``\"Uber Abbildung von Mannigfaltigkeiten'', Math. Ann., 71, pp. 97-115, [1911]
\bibitem{birkhoff1913}Birkhoff,G.D., ``Proof of Poincar\'e's Geometric Theorem'', Trans. Amer. Math. Soc., 14, pp. 14-22, [1913]
\bibitem{birkhoff1925}Birkhoff,G.D., ``An Extension of Poincar\'e's Last Geometric Theorem'', Acta Math., 47, pp. 297-311, [1925]
\bibitem{poincare1912}Poincar\'e,H., ``Sur un Theor\`eme de G\'eom\'etrie'', Rend. Circ. Mat. Palermo, 33, pp. 375-407, [1912]
\bibitem{brownnwumann977}Brown,H.,NeumannD., ``Proof of the Poincar\'e-Birkhoff Fixed-Point Theorem'', Michigan Math. J., 24, pp. 21-31, [1977]

\end{thebibliography}

\end{document}
